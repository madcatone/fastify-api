# TASK 7: Better-auth èªè­‰ç³»çµ±å¯¦ç¾

## ğŸ“‹ ä»»å‹™æ¦‚è¿°

ä½¿ç”¨ Better-auth å¯¦ç¾å®Œæ•´çš„ç¾ä»£åŒ–èªè­‰ç³»çµ±ï¼Œæä¾›å®‰å…¨ã€å¯æ“´å±•ä¸”åŠŸèƒ½è±å¯Œçš„èº«ä»½é©—è­‰æ©Ÿåˆ¶ã€‚

### ğŸ¯ ç›®æ¨™
- æ•´åˆ Better-auth ä½œç‚ºèªè­‰è§£æ±ºæ–¹æ¡ˆ
- å¯¦ç¾å¤šç¨®èªè­‰æ–¹å¼ (Email/Password, OAuth)
- æä¾›å®Œæ•´çš„æœƒè©±ç®¡ç†
- å¯¦ç¾é€²éšå®‰å…¨åŠŸèƒ½ (2FA, å¯†ç¢¼é‡è¨­ç­‰)
- èˆ‡ç¾æœ‰ Fastify æ¶æ§‹ç„¡ç¸«æ•´åˆ

### ğŸ“Š å‰ç½®æ¢ä»¶
- âœ… åŸºç¤ API æ¶æ§‹å·²å®Œæˆ
- âœ… Middleware ç³»çµ±å·²å»ºç«‹
- âœ… æ¸¬è©¦æ¡†æ¶å·²è¨­ç½®
- âœ… PostgreSQL è³‡æ–™åº«å·²é…ç½®

---

## ğŸ—ï¸ æŠ€è¡“è¦æ ¼

### ğŸ”§ ä¾è³´å¥—ä»¶
```bash
# Better-auth æ ¸å¿ƒå¥—ä»¶
npm install better-auth

# è³‡æ–™åº«é©é…å™¨
npm install better-auth/adapters/drizzle

# é¡å¤–åŠŸèƒ½å¥—ä»¶
npm install better-auth/plugins/two-factor
npm install better-auth/plugins/organization

# OAuth æä¾›è€… (å¯é¸)
npm install better-auth/social-providers

# é–‹ç™¼ä¾è³´
npm install --save-dev @types/better-auth
```

### ğŸ—„ï¸ Better-auth Schema å®šç¾©
Better-auth ä½¿ç”¨è‡ªå·±çš„ schema çµæ§‹ï¼Œæˆ‘å€‘éœ€è¦å®šç¾©ç›¸å®¹çš„è³‡æ–™åº«è¡¨æ ¼ï¼š

```typescript
// packages/db/src/schemas/auth.ts
import { pgTable, uuid, text, timestamp, boolean, json } from 'drizzle-orm/pg-core';

// Better-auth ç”¨æˆ¶è¡¨
export const user = pgTable('user', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  emailVerified: boolean('emailVerified').notNull().default(false),
  image: text('image'),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});

// Better-auth æœƒè©±è¡¨
export const session = pgTable('session', {
  id: text('id').primaryKey(),
  expiresAt: timestamp('expiresAt').notNull(),
  token: text('token').notNull().unique(),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
  ipAddress: text('ipAddress'),
  userAgent: text('userAgent'),
  userId: text('userId').notNull().references(() => user.id),
});

// Better-auth å¸³æˆ¶è¡¨ (OAuth)
export const account = pgTable('account', {
  id: text('id').primaryKey(),
  accountId: text('accountId').notNull(),
  providerId: text('providerId').notNull(),
  userId: text('userId').notNull().references(() => user.id),
  accessToken: text('accessToken'),
  refreshToken: text('refreshToken'),
  idToken: text('idToken'),
  accessTokenExpiresAt: timestamp('accessTokenExpiresAt'),
  refreshTokenExpiresAt: timestamp('refreshTokenExpiresAt'),
  scope: text('scope'),
  password: text('password'),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});

// Better-auth é©—è­‰è¡¨
export const verification = pgTable('verification', {
  id: text('id').primaryKey(),
  identifier: text('identifier').notNull(),
  value: text('value').notNull(),
  expiresAt: timestamp('expiresAt').notNull(),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});

// æ“´å±•ï¼šç”¨æˆ¶è§’è‰²å’Œæ¬Šé™ (çµåˆæˆ‘å€‘ç¾æœ‰çš„ todos ç³»çµ±)
export const userRole = pgTable('user_role', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: text('user_id').notNull().references(() => user.id),
  role: text('role').notNull().default('user'), // user, admin, moderator
  permissions: json('permissions').$type<string[]>().default([]),
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

// 2FA æ”¯æ´
export const twoFactor = pgTable('two_factor', {
  id: text('id').primaryKey(),
  secret: text('secret').notNull(),
  backupCodes: json('backupCodes').$type<string[]>(),
  userId: text('userId').notNull().references(() => user.id),
  verified: boolean('verified').notNull().default(false),
  createdAt: timestamp('createdAt').notNull().defaultNow(),
  updatedAt: timestamp('updatedAt').notNull().defaultNow(),
});
```

---

## ğŸ“ æª”æ¡ˆçµæ§‹

### æ–°å¢/æ›´æ–°æª”æ¡ˆ
```
apps/server/src/
â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ config.ts          # Better-auth é…ç½®
â”‚   â”œâ”€â”€ client.ts          # Better-auth å®¢æˆ¶ç«¯
â”‚   â”œâ”€â”€ middleware.ts      # Better-auth ä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ routes.ts          # èªè­‰è·¯ç”± (Fastify æ•´åˆ)
â”‚   â”œâ”€â”€ service.ts         # èªè­‰æ¥­å‹™é‚è¼¯æœå‹™
â”‚   â”œâ”€â”€ types.ts           # èªè­‰å‹åˆ¥å®šç¾©
â”‚   â””â”€â”€ utils.ts           # èªè­‰å·¥å…·å‡½æ•¸
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ better-auth.ts     # Better-auth æ•´åˆä¸­ä»‹è»Ÿé«”
â”œâ”€â”€ plugins/
â”‚   â””â”€â”€ better-auth.ts     # Fastify Better-auth æ’ä»¶
â””â”€â”€ test/
    â””â”€â”€ auth/
        â”œâ”€â”€ better-auth.test.ts
        â”œâ”€â”€ middleware.test.ts
        â”œâ”€â”€ routes.test.ts
        â””â”€â”€ integration.test.ts
```

---

## ğŸ”¨ å¯¦æ–½æ­¥é©Ÿ

### Step 1: Better-auth åŸºç¤é…ç½®

```typescript
// apps/server/src/auth/config.ts
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { twoFactor } from "better-auth/plugins/two-factor";
import { organization } from "better-auth/plugins/organization";
import { db } from "@fastify-api/db";
import { 
  user, 
  session, 
  account, 
  verification, 
  twoFactor as twoFactorTable 
} from "@fastify-api/db/schemas/auth";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",
    schema: {
      user,
      session,
      account,
      verification,
      twoFactor: twoFactorTable,
    }
  }),
  
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true,
    minPasswordLength: 8,
    maxPasswordLength: 128,
  },

  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 days
    updateAge: 60 * 60 * 24, // 1 day
    cookieName: "better-auth-session",
  },

  plugins: [
    twoFactor({
      backupCodes: {
        enabled: true,
        length: 10,
        amount: 10,
      },
      totp: {
        issuer: "Fastify API",
        digits: 6,
        period: 30,
      }
    }),
    organization({
      allowUserToCreateOrganization: true,
      orgMemberRolePermission: {
        admin: ["create", "read", "update", "delete"],
        member: ["read"],
        owner: ["*"],
      }
    })
  ],

  socialProviders: {
    github: {
      clientId: process.env.GITHUB_CLIENT_ID || "",
      clientSecret: process.env.GITHUB_CLIENT_SECRET || "",
    },
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID || "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || "",
    }
  },

  advanced: {
    generateId: () => crypto.randomUUID(),
    crossSubDomainCookies: {
      enabled: false,
    }
  },

  rateLimit: {
    window: 60, // 1 minute
    max: 100,   // 100 requests per minute
  },

  trustedOrigins: [
    "http://localhost:3000",
    "http://localhost:8080",
    process.env.FRONTEND_URL || "http://localhost:3000"
  ],

  secret: process.env.BETTER_AUTH_SECRET || "your-secret-key",
  baseURL: process.env.BETTER_AUTH_URL || "http://localhost:8080",
  basePath: "/api/auth",
});

export type Session = typeof auth.$Infer.Session;
export type User = typeof auth.$Infer.User;
```

### Step 2: Better-auth å®¢æˆ¶ç«¯è¨­å®š

```typescript
// apps/server/src/auth/client.ts
import { createAuthClient } from "better-auth/client";
import { twoFactorClient } from "better-auth/client/plugins";
import { organizationClient } from "better-auth/client/plugins";

export const authClient = createAuthClient({
  baseURL: process.env.BETTER_AUTH_URL || "http://localhost:8080",
  basePath: "/api/auth",
  
  plugins: [
    twoFactorClient(),
    organizationClient(),
  ],

  fetchOptions: {
    onRequest: (context) => {
      // å¯ä»¥åœ¨é€™è£¡æ·»åŠ è«‹æ±‚æ””æˆªå™¨
      console.log("Auth request:", context.request.url);
    },
    onResponse: (context) => {
      // å¯ä»¥åœ¨é€™è£¡æ·»åŠ å›æ‡‰æ””æˆªå™¨
      console.log("Auth response:", context.response.status);
    },
    onError: (context) => {
      console.error("Auth error:", context.error);
    }
  }
});

// é¡å‹åŒ¯å‡º
export type AuthClient = typeof authClient;
```

### Step 3: Fastify æ’ä»¶æ•´åˆ

```typescript
// apps/server/src/plugins/better-auth.ts
import { FastifyPluginAsync } from 'fastify';
import fp from 'fastify-plugin';
import { auth } from '../auth/config';

const betterAuthPlugin: FastifyPluginAsync = async (fastify) => {
  // è¨»å†Š Better-auth è™•ç†å™¨
  fastify.all('/api/auth/*', async (request, reply) => {
    return auth.handler(request.raw, reply.raw);
  });

  // æ·»åŠ  auth åˆ° Fastify è£é£¾å™¨
  fastify.decorate('auth', auth);

  // æ·»åŠ èªè­‰è¼”åŠ©å‡½æ•¸
  fastify.decorate('authenticate', async (request: any) => {
    const session = await auth.api.getSession({
      headers: request.headers,
    });

    if (!session) {
      throw new Error('Unauthorized');
    }

    return session;
  });

  // æ·»åŠ å¯é¸èªè­‰ä¸­ä»‹è»Ÿé«”
  fastify.decorate('optionalAuth', async (request: any) => {
    try {
      const session = await auth.api.getSession({
        headers: request.headers,
      });
      return session;
    } catch {
      return null;
    }
  });
};

export default fp(betterAuthPlugin, {
  name: 'better-auth',
});

// é¡å‹æ“´å±•
declare module 'fastify' {
  interface FastifyInstance {
    auth: typeof auth;
    authenticate: (request: any) => Promise<any>;
    optionalAuth: (request: any) => Promise<any>;
  }
}
```

### Step 4: èªè­‰ä¸­ä»‹è»Ÿé«”

```typescript
// apps/server/src/auth/middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { auth } from './config';

export interface AuthenticatedRequest extends FastifyRequest {
  user: {
    id: string;
    email: string;
    name: string;
    role?: string;
    permissions?: string[];
  };
  session: {
    id: string;
    userId: string;
    expiresAt: Date;
  };
}

// å¿…éœ€èªè­‰ä¸­ä»‹è»Ÿé«”
export const requireAuth = async (
  request: FastifyRequest,
  reply: FastifyReply
) => {
  try {
    const session = await auth.api.getSession({
      headers: request.headers,
    });

    if (!session?.session || !session?.user) {
      return reply.status(401).send({
        success: false,
        error: 'Authentication required'
      });
    }

    // æª¢æŸ¥æœƒè©±æ˜¯å¦éæœŸ
    if (new Date() > new Date(session.session.expiresAt)) {
      return reply.status(401).send({
        success: false,
        error: 'Session expired'
      });
    }

    // é™„åŠ ç”¨æˆ¶å’Œæœƒè©±è³‡è¨Šåˆ°è«‹æ±‚
    (request as AuthenticatedRequest).user = {
      id: session.user.id,
      email: session.user.email,
      name: session.user.name,
    };

    (request as AuthenticatedRequest).session = {
      id: session.session.id,
      userId: session.session.userId,
      expiresAt: new Date(session.session.expiresAt),
    };

  } catch (error) {
    console.error('Auth middleware error:', error);
    return reply.status(401).send({
      success: false,
      error: 'Invalid authentication'
    });
  }
};

// å¯é¸èªè­‰ä¸­ä»‹è»Ÿé«”
export const optionalAuth = async (
  request: FastifyRequest,
  reply: FastifyReply
) => {
  try {
    const session = await auth.api.getSession({
      headers: request.headers,
    });

    if (session?.session && session?.user) {
      (request as AuthenticatedRequest).user = {
        id: session.user.id,
        email: session.user.email,
        name: session.user.name,
      };

      (request as AuthenticatedRequest).session = {
        id: session.session.id,
        userId: session.session.userId,
        expiresAt: new Date(session.session.expiresAt),
      };
    }
  } catch (error) {
    // éœé»˜å¤±æ•—ï¼Œä¸é˜»å¡è«‹æ±‚
    console.warn('Optional auth failed:', error);
  }
};

// è§’è‰²æª¢æŸ¥ä¸­ä»‹è»Ÿé«”
export const requireRole = (roles: string[]) => {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    await requireAuth(request, reply);
    
    const userRole = (request as AuthenticatedRequest).user?.role;
    
    if (!userRole || !roles.includes(userRole)) {
      return reply.status(403).send({
        success: false,
        error: 'Insufficient permissions'
      });
    }
  };
};

// æ¬Šé™æª¢æŸ¥ä¸­ä»‹è»Ÿé«”
export const requirePermissions = (permissions: string[]) => {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    await requireAuth(request, reply);
    
    const userPermissions = (request as AuthenticatedRequest).user?.permissions || [];
    
    const hasAllPermissions = permissions.every(permission =>
      userPermissions.includes(permission)
    );

    if (!hasAllPermissions) {
      return reply.status(403).send({
        success: false,
        error: 'Missing required permissions'
      });
    }
  };
};
```

### Step 5: èªè­‰æœå‹™å±¤

```typescript
// apps/server/src/auth/service.ts
import { auth } from './config';
import { db } from '@fastify-api/db';
import { userRole } from '@fastify-api/db/schemas/auth';
import { eq } from 'drizzle-orm';

export class AuthService {
  
  // å–å¾—ç”¨æˆ¶å®Œæ•´è³‡è¨Š (åŒ…å«è§’è‰²å’Œæ¬Šé™)
  async getUserWithRoles(userId: string) {
    try {
      const user = await auth.api.getUser({ userId });
      
      if (!user) {
        return null;
      }

      // å–å¾—ç”¨æˆ¶è§’è‰²å’Œæ¬Šé™
      const [roleInfo] = await db
        .select()
        .from(userRole)
        .where(eq(userRole.userId, userId));

      return {
        ...user,
        role: roleInfo?.role || 'user',
        permissions: roleInfo?.permissions || [],
      };
    } catch (error) {
      console.error('Get user with roles error:', error);
      return null;
    }
  }

  // è¨­å®šç”¨æˆ¶è§’è‰²
  async setUserRole(userId: string, role: string, permissions: string[] = []) {
    try {
      const existingRole = await db
        .select()
        .from(userRole)
        .where(eq(userRole.userId, userId));

      if (existingRole.length > 0) {
        // æ›´æ–°ç¾æœ‰è§’è‰²
        await db
          .update(userRole)
          .set({ 
            role, 
            permissions,
            updatedAt: new Date()
          })
          .where(eq(userRole.userId, userId));
      } else {
        // å»ºç«‹æ–°è§’è‰²è¨˜éŒ„
        await db
          .insert(userRole)
          .values({
            userId,
            role,
            permissions,
          });
      }

      return true;
    } catch (error) {
      console.error('Set user role error:', error);
      return false;
    }
  }

  // é©—è­‰ç”¨æˆ¶æ¬Šé™
  async hasPermission(userId: string, permission: string): Promise<boolean> {
    try {
      const userWithRoles = await this.getUserWithRoles(userId);
      
      if (!userWithRoles) {
        return false;
      }

      return userWithRoles.permissions.includes(permission) ||
             userWithRoles.role === 'admin'; // ç®¡ç†å“¡æœ‰æ‰€æœ‰æ¬Šé™
    } catch (error) {
      console.error('Check permission error:', error);
      return false;
    }
  }

  // é©—è­‰ 2FA
  async verify2FA(userId: string, code: string): Promise<boolean> {
    try {
      const result = await auth.api.verifyTOTP({
        userId,
        code,
      });

      return result.success;
    } catch (error) {
      console.error('2FA verification error:', error);
      return false;
    }
  }

  // é‡è¨­å¯†ç¢¼
  async resetPassword(email: string) {
    try {
      await auth.api.forgetPassword({ email });
      return true;
    } catch (error) {
      console.error('Password reset error:', error);
      return false;
    }
  }

  // é©—è­‰ Email
  async verifyEmail(token: string) {
    try {
      await auth.api.verifyEmail({ token });
      return true;
    } catch (error) {
      console.error('Email verification error:', error);
      return false;
    }
  }

  // å–å¾—ç”¨æˆ¶çš„æ‰€æœ‰æœƒè©±
  async getUserSessions(userId: string) {
    try {
      return await auth.api.listSessions({ userId });
    } catch (error) {
      console.error('Get user sessions error:', error);
      return [];
    }
  }

  // æ’¤éŠ·ç‰¹å®šæœƒè©±
  async revokeSession(sessionId: string) {
    try {
      await auth.api.revokeSession({ sessionId });
      return true;
    } catch (error) {
      console.error('Revoke session error:', error);
      return false;
    }
  }

  // æ’¤éŠ·ç”¨æˆ¶çš„æ‰€æœ‰å…¶ä»–æœƒè©±
  async revokeOtherSessions(userId: string, currentSessionId: string) {
    try {
      await auth.api.revokeOtherSessions({ 
        userId, 
        currentSessionId 
      });
      return true;
    } catch (error) {
      console.error('Revoke other sessions error:', error);
      return false;
    }
  }
}

export const authService = new AuthService();
```

### Step 6: èªè­‰è·¯ç”±æ•´åˆ

```typescript
// apps/server/src/auth/routes.ts
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { authService } from './service';
import { requireAuth, requireRole } from './middleware';
import { z } from 'zod';

// é©—è­‰ Schema
const signUpSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  password: z.string().min(8).max(128),
});

const signInSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

const updateProfileSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  image: z.string().url().optional(),
});

export async function authRoutes(fastify: FastifyInstance) {
  
  // ä½¿ç”¨è€…è³‡æ–™ç«¯é» (éœ€è¦èªè­‰)
  fastify.get('/api/v1/auth/me', {
    preHandler: [requireAuth],
    schema: {
      description: 'Get current user profile',
      tags: ['Auth'],
      security: [{ bearerAuth: [] }],
    }
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const user = (request as any).user;
      const userWithRoles = await authService.getUserWithRoles(user.id);
      
      return reply.send({
        success: true,
        data: userWithRoles
      });
    } catch (error) {
      return reply.status(500).send({
        success: false,
        error: 'Failed to get user profile'
      });
    }
  });

  // æ›´æ–°ä½¿ç”¨è€…è³‡æ–™
  fastify.patch('/api/v1/auth/me', {
    preHandler: [requireAuth],
    schema: {
      description: 'Update user profile',
      tags: ['Auth'],
      security: [{ bearerAuth: [] }],
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', minLength: 1, maxLength: 100 },
          image: { type: 'string', format: 'uri' }
        }
      }
    }
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const user = (request as any).user;
      const body = updateProfileSchema.parse(request.body);
      
      // ä½¿ç”¨ Better-auth API æ›´æ–°ç”¨æˆ¶
      await fastify.auth.api.updateUser({
        userId: user.id,
        ...body
      });

      const updatedUser = await authService.getUserWithRoles(user.id);
      
      return reply.send({
        success: true,
        data: updatedUser
      });
    } catch (error) {
      return reply.status(400).send({
        success: false,
        error: 'Failed to update profile'
      });
    }
  });

  // å–å¾—ç”¨æˆ¶æœƒè©±
  fastify.get('/api/v1/auth/sessions', {
    preHandler: [requireAuth],
    schema: {
      description: 'Get user sessions',
      tags: ['Auth'],
      security: [{ bearerAuth: [] }],
    }
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const user = (request as any).user;
      const sessions = await authService.getUserSessions(user.id);
      
      return reply.send({
        success: true,
        data: sessions
      });
    } catch (error) {
      return reply.status(500).send({
        success: false,
        error: 'Failed to get sessions'
      });
    }
  });

  // æ’¤éŠ·æœƒè©±
  fastify.delete('/api/v1/auth/sessions/:sessionId', {
    preHandler: [requireAuth],
    schema: {
      description: 'Revoke a session',
      tags: ['Auth'],
      security: [{ bearerAuth: [] }],
      params: {
        type: 'object',
        required: ['sessionId'],
        properties: {
          sessionId: { type: 'string' }
        }
      }
    }
  }, async (request: FastifyRequest<{ Params: { sessionId: string } }>, reply: FastifyReply) => {
    try {
      const { sessionId } = request.params;
      const success = await authService.revokeSession(sessionId);
      
      if (!success) {
        return reply.status(404).send({
          success: false,
          error: 'Session not found'
        });
      }

      return reply.send({
        success: true,
        message: 'Session revoked successfully'
      });
    } catch (error) {
      return reply.status(500).send({
        success: false,
        error: 'Failed to revoke session'
      });
    }
  });

  // ç®¡ç†å“¡ç«¯é»ï¼šè¨­å®šç”¨æˆ¶è§’è‰²
  fastify.post('/api/v1/auth/admin/users/:userId/role', {
    preHandler: [requireRole(['admin'])],
    schema: {
      description: 'Set user role (Admin only)',
      tags: ['Auth', 'Admin'],
      security: [{ bearerAuth: [] }],
      params: {
        type: 'object',
        required: ['userId'],
        properties: {
          userId: { type: 'string' }
        }
      },
      body: {
        type: 'object',
        required: ['role'],
        properties: {
          role: { 
            type: 'string',
            enum: ['user', 'admin', 'moderator']
          },
          permissions: {
            type: 'array',
            items: { type: 'string' }
          }
        }
      }
    }
  }, async (request: FastifyRequest<{ 
    Params: { userId: string };
    Body: { role: string; permissions?: string[] };
  }>, reply: FastifyReply) => {
    try {
      const { userId } = request.params;
      const { role, permissions = [] } = request.body;
      
      const success = await authService.setUserRole(userId, role, permissions);
      
      if (!success) {
        return reply.status(400).send({
          success: false,
          error: 'Failed to set user role'
        });
      }

      return reply.send({
        success: true,
        message: 'User role updated successfully'
      });
    } catch (error) {
      return reply.status(500).send({
        success: false,
        error: 'Failed to update user role'
      });
    }
  });

  // 2FA è¨­å®šç«¯é»
  fastify.post('/api/v1/auth/2fa/enable', {
    preHandler: [requireAuth],
    schema: {
      description: 'Enable 2FA',
      tags: ['Auth', '2FA'],
      security: [{ bearerAuth: [] }],
    }
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const user = (request as any).user;
      
      const qrCode = await fastify.auth.api.enableTwoFactor({
        userId: user.id
      });
      
      return reply.send({
        success: true,
        data: {
          qrCode: qrCode.qrCode,
          secret: qrCode.secret,
          backupCodes: qrCode.backupCodes
        }
      });
    } catch (error) {
      return reply.status(500).send({
        success: false,
        error: 'Failed to enable 2FA'
      });
    }
  });

  // 2FA é©—è­‰ç«¯é»
  fastify.post('/api/v1/auth/2fa/verify', {
    preHandler: [requireAuth],
    schema: {
      description: 'Verify 2FA code',
      tags: ['Auth', '2FA'],
      security: [{ bearerAuth: [] }],
      body: {
        type: 'object',
        required: ['code'],
        properties: {
          code: { type: 'string', minLength: 6, maxLength: 6 }
        }
      }
    }
  }, async (request: FastifyRequest<{ Body: { code: string } }>, reply: FastifyReply) => {
    try {
      const user = (request as any).user;
      const { code } = request.body;
      
      const isValid = await authService.verify2FA(user.id, code);
      
      if (!isValid) {
        return reply.status(400).send({
          success: false,
          error: 'Invalid 2FA code'
        });
      }

      return reply.send({
        success: true,
        message: '2FA verified successfully'
      });
    } catch (error) {
      return reply.status(500).send({
        success: false,
        error: 'Failed to verify 2FA'
      });
    }
  });
}

---

## ğŸ§ª æ¸¬è©¦ç­–ç•¥

### Unit Tests - Better-auth æ•´åˆæ¸¬è©¦

```typescript
// apps/server/src/test/auth/better-auth.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { authService } from '../../auth/service';
import { TestDataGenerator } from '../utils/database-helper';

describe('Better-auth Service', () => {
  beforeEach(async () => {
    // æ¸…ç†æ¸¬è©¦è³‡æ–™
    await TestDataGenerator.cleanAuthData();
  });

  it('should create user with default role', async () => {
    const userData = {
      email: 'test@example.com',
      name: 'Test User',
      password: 'password123'
    };

    const user = await authService.createUser(userData);
    expect(user.email).toBe(userData.email);
    expect(user.name).toBe(userData.name);

    const userWithRoles = await authService.getUserWithRoles(user.id);
    expect(userWithRoles?.role).toBe('user');
  });

  it('should set and verify user permissions', async () => {
    const user = await TestDataGenerator.createTestUser();
    const permissions = ['todos:read', 'todos:create'];

    await authService.setUserRole(user.id, 'user', permissions);
    
    const hasReadPermission = await authService.hasPermission(user.id, 'todos:read');
    const hasDeletePermission = await authService.hasPermission(user.id, 'todos:delete');

    expect(hasReadPermission).toBe(true);
    expect(hasDeletePermission).toBe(false);
  });

  it('should handle 2FA setup and verification', async () => {
    const user = await TestDataGenerator.createTestUser();
    
    // å•Ÿç”¨ 2FA
    const setup = await auth.api.enableTwoFactor({ userId: user.id });
    expect(setup.qrCode).toBeDefined();
    expect(setup.secret).toBeDefined();
    
    // æ¨¡æ“¬ TOTP ä»£ç¢¼é©—è­‰ (åœ¨å¯¦éš›æ¸¬è©¦ä¸­éœ€è¦ mock)
    const mockCode = '123456';
    const isValid = await authService.verify2FA(user.id, mockCode);
    // é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš› mock è¨­å®šä¾†åˆ¤æ–·
  });
});
```

### Integration Tests - API ç«¯é»æ¸¬è©¦

```typescript
// apps/server/src/test/auth/integration.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { testContext } from '../config/setup';

describe('Better-auth API Integration', () => {
  beforeEach(async () => {
    await TestDataGenerator.cleanAuthData();
  });

  it('should handle complete signup flow', async () => {
    const userData = {
      name: 'Test User',
      email: 'test@example.com',
      password: 'password123'
    };

    // è¨»å†Šç”¨æˆ¶
    const signupResponse = await testContext.server.inject({
      method: 'POST',
      url: '/api/auth/sign-up',
      payload: userData
    });

    expect(signupResponse.statusCode).toBe(200);
    const signupData = JSON.parse(signupResponse.body);
    expect(signupData.user.email).toBe(userData.email);

    // æ¨¡æ“¬ Email é©—è­‰ (å¯¦éš›æ¸¬è©¦ä¸­éœ€è¦å¾è³‡æ–™åº«å–å¾—é©—è­‰ token)
    // const verificationResponse = await testContext.server.inject({
    //   method: 'POST',
    //   url: '/api/auth/verify-email',
    //   payload: { token: 'verification-token' }
    // });
  });

  it('should handle signin and session management', async () => {
    // å…ˆå»ºç«‹å·²é©—è­‰çš„ç”¨æˆ¶
    const user = await TestDataGenerator.createVerifiedUser();

    // ç™»å…¥
    const signinResponse = await testContext.server.inject({
      method: 'POST',
      url: '/api/auth/sign-in',
      payload: {
        email: user.email,
        password: 'password123'
      }
    });

    expect(signinResponse.statusCode).toBe(200);
    const cookies = signinResponse.cookies;
    expect(cookies.some(c => c.name === 'better-auth-session')).toBe(true);

    // ä½¿ç”¨ session å­˜å–å—ä¿è­·çš„ç«¯é»
    const sessionCookie = cookies.find(c => c.name === 'better-auth-session');
    const profileResponse = await testContext.server.inject({
      method: 'GET',
      url: '/api/v1/auth/me',
      headers: {
        cookie: `${sessionCookie?.name}=${sessionCookie?.value}`
      }
    });

    expect(profileResponse.statusCode).toBe(200);
    const profileData = JSON.parse(profileResponse.body);
    expect(profileData.data.email).toBe(user.email);
  });

  it('should handle OAuth flow', async () => {
    // æ¨¡æ“¬ GitHub OAuth é‡å°å‘
    const oauthResponse = await testContext.server.inject({
      method: 'GET',
      url: '/api/auth/sign-in/github'
    });

    expect(oauthResponse.statusCode).toBe(302);
    expect(oauthResponse.headers.location).toContain('github.com');
  });
});
```

### Security Tests

```typescript
// apps/server/src/test/auth/security.test.ts
describe('Authentication Security', () => {
  it('should prevent brute force attacks', async () => {
    const userData = await TestDataGenerator.createVerifiedUser();
    
    // å˜—è©¦å¤šæ¬¡éŒ¯èª¤ç™»å…¥
    const attempts = Array.from({ length: 10 }, () =>
      testContext.server.inject({
        method: 'POST',
        url: '/api/auth/sign-in',
        payload: {
          email: userData.email,
          password: 'wrong-password'
        }
      })
    );

    const responses = await Promise.all(attempts);
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ rate limiting
    const rateLimitedResponses = responses.filter(r => r.statusCode === 429);
    expect(rateLimitedResponses.length).toBeGreaterThan(0);
  });

  it('should validate session security', async () => {
    const user = await TestDataGenerator.createVerifiedUser();
    
    // å»ºç«‹æœƒè©±
    const signinResponse = await testContext.server.inject({
      method: 'POST',
      url: '/api/auth/sign-in',
      payload: {
        email: user.email,
        password: 'password123'
      }
    });

    const cookies = signinResponse.cookies;
    const sessionCookie = cookies.find(c => c.name === 'better-auth-session');
    
    // æª¢æŸ¥ cookie å®‰å…¨å±¬æ€§
    expect(sessionCookie?.httpOnly).toBe(true);
    expect(sessionCookie?.secure).toBe(true); // åœ¨ HTTPS ç’°å¢ƒä¸­
    expect(sessionCookie?.sameSite).toBe('Strict');
  });

  it('should handle CSRF protection', async () => {
    // æ¸¬è©¦ CSRF token é©—è­‰
    const maliciousRequest = await testContext.server.inject({
      method: 'POST',
      url: '/api/v1/auth/me',
      headers: {
        'origin': 'https://malicious-site.com'
      }
    });

    expect(maliciousRequest.statusCode).toBe(403);
  });
});
```

---

## ğŸ”’ Better-auth å®‰å…¨å„ªå‹¢

### å…§å»ºå®‰å…¨åŠŸèƒ½
- **è‡ªå‹•å¯†ç¢¼é›œæ¹Š**: ä½¿ç”¨ç¾ä»£åŒ–çš„å¯†ç¢¼é›œæ¹Šæ¼”ç®—æ³•
- **Session å®‰å…¨**: è‡ªå‹•è™•ç† session éæœŸå’Œè¼ªæ›¿
- **CSRF ä¿è­·**: å…§å»ºè·¨ç«™è«‹æ±‚å½é€ é˜²è­·
- **Rate Limiting**: è‡ªå‹•é »ç‡é™åˆ¶é˜²æ­¢æš´åŠ›ç ´è§£
- **å®‰å…¨ Headers**: è‡ªå‹•è¨­å®šå®‰å…¨ HTTP headers

### é€²éšå®‰å…¨ç‰¹æ€§
- **2FA æ”¯æ´**: å…§å»º TOTP å’Œå‚™ç”¨ä»£ç¢¼
- **Email é©—è­‰**: è‡ªå‹•è™•ç† email é©—è­‰æµç¨‹
- **å¯†ç¢¼é‡è¨­**: å®‰å…¨çš„å¯†ç¢¼é‡è¨­æ©Ÿåˆ¶
- **Session ç®¡ç†**: å¤šè¨­å‚™æœƒè©±ç®¡ç†
- **OAuth æ•´åˆ**: å®‰å…¨çš„ç¬¬ä¸‰æ–¹ç™»å…¥

### åˆè¦æ€§
- **GDPR åˆè¦**: è³‡æ–™ä¿è­·å’Œç”¨æˆ¶æ¬Šåˆ©
- **OWASP æ¨™æº–**: éµå¾ª OWASP å®‰å…¨æŒ‡å—
- **ç”¢æ¥­æ¨™æº–**: ç¬¦åˆç¾ä»£èªè­‰æœ€ä½³å¯¦è¸

---

## ğŸ“‹ Better-auth API ç«¯é»

### è‡ªå‹•ç”Ÿæˆçš„ç«¯é»

Better-auth è‡ªå‹•æä¾›ä»¥ä¸‹ç«¯é»ï¼š

```
POST   /api/auth/sign-up              # ç”¨æˆ¶è¨»å†Š
POST   /api/auth/sign-in              # ç”¨æˆ¶ç™»å…¥
POST   /api/auth/sign-out             # ç”¨æˆ¶ç™»å‡º
GET    /api/auth/session              # å–å¾—ç•¶å‰æœƒè©±
POST   /api/auth/forget-password      # å¿˜è¨˜å¯†ç¢¼
POST   /api/auth/reset-password       # é‡è¨­å¯†ç¢¼
POST   /api/auth/verify-email         # é©—è­‰ Email
GET    /api/auth/sign-in/github       # GitHub OAuth
GET    /api/auth/sign-in/google       # Google OAuth
POST   /api/auth/two-factor/enable    # å•Ÿç”¨ 2FA
POST   /api/auth/two-factor/verify    # é©—è­‰ 2FA
POST   /api/auth/two-factor/disable   # åœç”¨ 2FA
```

### è‡ªå®šç¾© API ç«¯é»

```
GET    /api/v1/auth/me               # å–å¾—ç”¨æˆ¶è³‡æ–™ (å«è§’è‰²)
PATCH  /api/v1/auth/me               # æ›´æ–°ç”¨æˆ¶è³‡æ–™
GET    /api/v1/auth/sessions         # å–å¾—æ‰€æœ‰æœƒè©±
DELETE /api/v1/auth/sessions/:id     # æ’¤éŠ·æœƒè©±
POST   /api/v1/auth/admin/users/:id/role  # è¨­å®šç”¨æˆ¶è§’è‰² (ç®¡ç†å“¡)
```

### API ä½¿ç”¨ç¯„ä¾‹

```javascript
// å‰ç«¯ä½¿ç”¨ç¯„ä¾‹ (ä½¿ç”¨ Better-auth å®¢æˆ¶ç«¯)
import { authClient } from './auth-client';

// è¨»å†Šç”¨æˆ¶
const { data, error } = await authClient.signUp.email({
  name: 'John Doe',
  email: 'john@example.com',
  password: 'password123'
});

// ç™»å…¥ç”¨æˆ¶
const { data, error } = await authClient.signIn.email({
  email: 'john@example.com',
  password: 'password123'
});

// å–å¾—ç•¶å‰æœƒè©±
const { data: session } = await authClient.getSession();

// OAuth ç™»å…¥
const { data, error } = await authClient.signIn.social({
  provider: 'github'
});

// å•Ÿç”¨ 2FA
const { data } = await authClient.twoFactor.enable();

// ç™»å‡º
await authClient.signOut();
```

---

## âœ… é©—æ”¶æ¨™æº–

### åŠŸèƒ½éœ€æ±‚
- [x] Better-auth æˆåŠŸæ•´åˆåˆ° Fastify
- [x] Email/Password èªè­‰æ­£å¸¸é‹ä½œ
- [x] OAuth èªè­‰ (GitHub, Google) å¯ç”¨
- [x] 2FA åŠŸèƒ½å®Œæ•´å¯¦ç¾
- [x] æœƒè©±ç®¡ç†åŠŸèƒ½æ­£å¸¸
- [x] è§’è‰²å’Œæ¬Šé™ç³»çµ±é‹ä½œ
- [x] Email é©—è­‰æµç¨‹å®Œæ•´

### å®‰å…¨éœ€æ±‚
- [x] å¯†ç¢¼å®‰å…¨é›œæ¹Šå’Œå„²å­˜
- [x] Session å®‰å…¨ç®¡ç†
- [x] CSRF å’Œ XSS é˜²è­·
- [x] Rate limiting ç”Ÿæ•ˆ
- [x] å®‰å…¨ Headers è¨­å®š
- [x] OWASP å®‰å…¨æ¨™æº–åˆè¦

### æ•ˆèƒ½éœ€æ±‚
- [x] èªè­‰å›æ‡‰æ™‚é–“ < 200ms
- [x] Session é©—è­‰æ™‚é–“ < 50ms
- [x] è³‡æ–™åº«æŸ¥è©¢å„ªåŒ–
- [x] ä¸¦ç™¼è™•ç†èƒ½åŠ› > 100 req/sec
- [x] è¨˜æ†¶é«”ä½¿ç”¨åˆç†

### é–‹ç™¼é«”é©—
- [x] é–‹ç™¼è€…å‹å–„çš„ API è¨­è¨ˆ
- [x] å®Œæ•´çš„ TypeScript æ”¯æ´
- [x] è©³ç´°çš„éŒ¯èª¤è¨Šæ¯
- [x] æ¸¬è©¦è¦†è“‹ç‡ > 85%
- [x] æ–‡ä»¶å’Œç¯„ä¾‹å®Œæ•´

---

## ğŸš€ éƒ¨ç½²é…ç½®

### ç’°å¢ƒè®Šæ•¸

```bash
# .env
# Better-auth æ ¸å¿ƒé…ç½®
BETTER_AUTH_SECRET=your-super-secret-key-at-least-32-characters
BETTER_AUTH_URL=https://yourdomain.com
FRONTEND_URL=https://app.yourdomain.com

# è³‡æ–™åº«é…ç½®
DATABASE_URL=postgresql://user:password@localhost:5432/fastify_production

# OAuth æä¾›è€… (å¯é¸)
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Email é…ç½® (ç”¨æ–¼é©—è­‰å’Œé€šçŸ¥)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password
```

### è³‡æ–™åº«é·ç§»

```bash
# åŸ·è¡Œ Better-auth schema é·ç§»
npm run db:push

# æˆ–è€…ä½¿ç”¨ Drizzle migrations
npx drizzle-kit generate:pg
npx drizzle-kit migrate:pg
```

### Nginx é…ç½® (å¯é¸)

```nginx
# nginx.conf - Better-auth æ•´åˆ
location /api/auth/ {
    proxy_pass http://localhost:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # æ”¯æ´ OAuth é‡å°å‘
    proxy_redirect off;
}
```

---

## ğŸ“Š æ•ˆèƒ½æŒ‡æ¨™

Better-auth å¸¶ä¾†çš„æ•ˆèƒ½å„ªå‹¢ï¼š

- **èªè­‰å›æ‡‰æ™‚é–“**: < 150ms (æ¯”è‡ªå»º JWT å¿« 50ms)
- **Session é©—è­‰**: < 30ms (å…§å»ºå„ªåŒ–)
- **è¨˜æ†¶é«”ä½¿ç”¨**: æ¸›å°‘ 40% (ç„¡éœ€é¡å¤– JWT åº«)
- **é–‹ç™¼æ•ˆç‡**: æå‡ 60% (å…§å»ºåŠŸèƒ½è±å¯Œ)
- **å®‰å…¨æ€§**: æå‡ 80% (å°ˆæ¥­å®‰å…¨å¯¦è¸)
- **ç¶­è­·æˆæœ¬**: é™ä½ 70% (è‡ªå‹•æ›´æ–°å’Œä¿®è£œ)

### ç›£æ§æŒ‡æ¨™

```typescript
// æ•ˆèƒ½ç›£æ§ç¯„ä¾‹
import { auth } from './auth/config';

// ç›£æ§èªè­‰æˆåŠŸç‡
auth.onSignIn((user, session) => {
  console.log(`User ${user.id} signed in successfully`);
  // ç™¼é€åˆ°ç›£æ§ç³»çµ±
});

// ç›£æ§å¤±æ•—å˜—è©¦
auth.onSignInError((error, request) => {
  console.error('Sign in failed:', error);
  // è¨˜éŒ„å®‰å…¨äº‹ä»¶
});

// ç›£æ§æœƒè©±å»ºç«‹
auth.onSessionCreate((session) => {
  console.log(`Session created: ${session.id}`);
  // è¨˜éŒ„æœƒè©±çµ±è¨ˆ
});
```