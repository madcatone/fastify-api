# TASK 4: åˆ†å±¤æ¶æ§‹é‡æ§‹

## ğŸ“‹ ä»»å‹™æ¦‚è¿°

é‡æ§‹æ‡‰ç”¨ç¨‹å¼æ¶æ§‹ï¼Œå»ºç«‹æ¸…æ™°çš„åˆ†å±¤æ¶æ§‹ï¼Œå°‡æ¥­å‹™é‚è¼¯ã€è³‡æ–™å­˜å–å’Œ API å±¤åˆ†é›¢ï¼Œæå‡ç¨‹å¼ç¢¼çš„å¯ç¶­è­·æ€§å’Œæ“´å±•æ€§ã€‚

### ğŸ¯ ç›®æ¨™
- å»ºç«‹ Controller-Service-Repository åˆ†å±¤æ¶æ§‹
- å¯¦ç¾ä¾è³´æ³¨å…¥å’Œæ§åˆ¶åè½‰
- åˆ†é›¢æ¥­å‹™é‚è¼¯å’Œ API é‚è¼¯
- å»ºç«‹çµ±ä¸€çš„ä¸­ä»‹è»Ÿé«”ç³»çµ±
- å¯¦ç¾æ¨¡çµ„åŒ–çš„è·¯ç”±ç®¡ç†

### ğŸ“Š å‰ç½®æ¢ä»¶
- âœ… TASK 3: CRUD æ“ä½œå·²å¯¦ç¾
- âœ… åŸºç¤éŒ¯èª¤è™•ç†ç³»çµ±å·²å»ºç«‹
- âœ… è³‡æ–™é©—è­‰æ©Ÿåˆ¶å·²å®Œæˆ

---

## ğŸ—ï¸ æ¶æ§‹è¨­è¨ˆ

### ğŸ”„ åˆ†å±¤æ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation      â”‚  â† HTTP å±¤ (Controllers, Routes, Middleware)
â”‚     Layer           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Business         â”‚  â† æ¥­å‹™é‚è¼¯å±¤ (Services, Validators)
â”‚     Layer           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Access        â”‚  â† è³‡æ–™å­˜å–å±¤ (Repositories, Database)
â”‚     Layer           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Infrastructure    â”‚  â† åŸºç¤è¨­æ–½å±¤ (External APIs, Files, Cache)
â”‚     Layer           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“ æ–°çš„æª”æ¡ˆçµæ§‹

```
apps/server/src/
â”œâ”€â”€ controllers/           # API æ§åˆ¶å™¨å±¤
â”‚   â”œâ”€â”€ base/             # åŸºç¤æ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ base.controller.ts
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ todos.controller.ts
â”‚   â”‚   â”œâ”€â”€ todos.routes.ts
â”‚   â”‚   â””â”€â”€ todos.types.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ services/             # æ¥­å‹™é‚è¼¯å±¤
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ base.service.ts
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ todos.service.ts
â”‚   â”‚   â””â”€â”€ todos.types.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ repositories/         # è³‡æ–™å­˜å–å±¤
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ base.repository.ts
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ todos.repository.ts
â”‚   â”‚   â””â”€â”€ todos.types.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ middleware/           # ä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ jwt.middleware.ts
â”‚   â”‚   â””â”€â”€ permissions.middleware.ts
â”‚   â”œâ”€â”€ validation/
â”‚   â”‚   â”œâ”€â”€ validation.middleware.ts
â”‚   â”‚   â””â”€â”€ sanitization.middleware.ts
â”‚   â”œâ”€â”€ error/
â”‚   â”‚   â”œâ”€â”€ error.middleware.ts
â”‚   â”‚   â””â”€â”€ not-found.middleware.ts
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ cors.middleware.ts
â”‚   â”‚   â”œâ”€â”€ helmet.middleware.ts
â”‚   â”‚   â””â”€â”€ rate-limit.middleware.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ shared/              # å…±ç”¨å…ƒä»¶
â”‚   â”œâ”€â”€ types/           # å…¨åŸŸå‹åˆ¥å®šç¾©
â”‚   â”œâ”€â”€ utils/           # å·¥å…·å‡½æ•¸
â”‚   â”œâ”€â”€ errors/          # éŒ¯èª¤è™•ç†
â”‚   â”œâ”€â”€ validators/      # é©—è­‰å™¨
â”‚   â””â”€â”€ constants/       # å¸¸æ•¸å®šç¾©
â”œâ”€â”€ config/              # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ database.ts
â”‚   â”œâ”€â”€ server.ts
â”‚   â”œâ”€â”€ auth.ts
â”‚   â””â”€â”€ index.ts
â””â”€â”€ main.ts              # æ‡‰ç”¨ç¨‹å¼å…¥å£é»
```

---

## ğŸ”¨ å¯¦æ–½æ­¥é©Ÿ

### Step 1: åŸºç¤æ§åˆ¶å™¨æŠ½è±¡é¡

```typescript
// apps/server/src/controllers/base/base.controller.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { ZodSchema } from 'zod';
import { createSuccessResponse, createErrorResponse } from '../../shared/utils/response';
import { ValidationError } from '../../shared/errors/base';

export abstract class BaseController {
  
  protected async validateInput<T>(
    schema: ZodSchema<T>, 
    data: unknown
  ): Promise<T> {
    try {
      return schema.parse(data);
    } catch (error) {
      if (error instanceof Error) {
        throw new ValidationError('Validation failed', error.message);
      }
      throw new ValidationError('Validation failed');
    }
  }

  protected sendSuccess<T>(
    reply: FastifyReply, 
    data: T, 
    statusCode: number = 200
  ) {
    return reply.status(statusCode).send(createSuccessResponse(data));
  }

  protected sendError(
    reply: FastifyReply, 
    error: string, 
    statusCode: number = 400,
    details?: any[]
  ) {
    return reply.status(statusCode).send(createErrorResponse(error, details));
  }

  protected sendCreated<T>(reply: FastifyReply, data: T) {
    return this.sendSuccess(reply, data, 201);
  }

  protected sendNoContent(reply: FastifyReply) {
    return reply.status(204).send();
  }

  // åˆ†é éŸ¿æ‡‰åŠ©æ‰‹
  protected sendPaginatedResponse<T>(
    reply: FastifyReply,
    result: {
      data: T[];
      total: number;
      page: number;
      limit: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    }
  ) {
    return this.sendSuccess(reply, {
      items: result.data,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        totalPages: result.totalPages,
        hasNext: result.hasNext,
        hasPrev: result.hasPrev
      }
    });
  }
}
```

### Step 2: Todos æ§åˆ¶å™¨é‡æ§‹

```typescript
// apps/server/src/controllers/todos/todos.controller.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { BaseController } from '../base/base.controller';
import { TodoService } from '../../services/todos/todos.service';
import {
  queryParamsSchema,
  createTodoSchema,
  updateTodoSchema,
  todoParamsSchema
} from '../../shared/validators/todos.validators';
import type { 
  GetTodosQuery,
  CreateTodoBody,
  UpdateTodoBody,
  TodoParams
} from './todos.types';

export class TodosController extends BaseController {
  
  constructor(private todoService: TodoService) {
    super();
  }

  // GET /api/v1/todos
  async getAllTodos(
    request: FastifyRequest<{ Querystring: GetTodosQuery }>,
    reply: FastifyReply
  ) {
    try {
      // é©—è­‰æŸ¥è©¢åƒæ•¸
      const queryParams = await this.validateInput(
        queryParamsSchema, 
        request.query
      );

      // èª¿ç”¨æœå‹™å±¤
      const result = await this.todoService.getTodos({
        pagination: {
          page: queryParams.page,
          limit: queryParams.limit
        },
        filters: {
          author: queryParams.author,
          isActive: queryParams.isActive,
          search: queryParams.search
        },
        sort: {
          field: queryParams.sortBy,
          order: queryParams.sortOrder
        }
      });

      return this.sendPaginatedResponse(reply, result);
    } catch (error) {
      throw error; // è®“å…¨åŸŸéŒ¯èª¤è™•ç†å™¨è™•ç†
    }
  }

  // GET /api/v1/todos/:id
  async getTodoById(
    request: FastifyRequest<{ Params: TodoParams }>,
    reply: FastifyReply
  ) {
    try {
      const params = await this.validateInput(todoParamsSchema, request.params);
      const todo = await this.todoService.getTodoById(params.id);
      
      return this.sendSuccess(reply, todo);
    } catch (error) {
      throw error;
    }
  }

  // POST /api/v1/todos
  async createTodo(
    request: FastifyRequest<{ Body: CreateTodoBody }>,
    reply: FastifyReply
  ) {
    try {
      const body = await this.validateInput(createTodoSchema, request.body);
      const newTodo = await this.todoService.createTodo(body);
      
      return this.sendCreated(reply, newTodo);
    } catch (error) {
      throw error;
    }
  }

  // PUT /api/v1/todos/:id
  async updateTodo(
    request: FastifyRequest<{ 
      Params: TodoParams; 
      Body: UpdateTodoBody 
    }>,
    reply: FastifyReply
  ) {
    try {
      const params = await this.validateInput(todoParamsSchema, request.params);
      const body = await this.validateInput(updateTodoSchema, request.body);
      
      const updatedTodo = await this.todoService.updateTodo(params.id, body);
      
      return this.sendSuccess(reply, updatedTodo);
    } catch (error) {
      throw error;
    }
  }

  // DELETE /api/v1/todos/:id
  async deleteTodo(
    request: FastifyRequest<{ Params: TodoParams }>,
    reply: FastifyReply
  ) {
    try {
      const params = await this.validateInput(todoParamsSchema, request.params);
      await this.todoService.deleteTodo(params.id);
      
      return this.sendNoContent(reply);
    } catch (error) {
      throw error;
    }
  }

  // PATCH /api/v1/todos/:id/status
  async toggleTodoStatus(
    request: FastifyRequest<{ Params: TodoParams }>,
    reply: FastifyReply
  ) {
    try {
      const params = await this.validateInput(todoParamsSchema, request.params);
      const todo = await this.todoService.toggleTodoStatus(params.id);
      
      return this.sendSuccess(reply, todo);
    } catch (error) {
      throw error;
    }
  }

  // GET /api/v1/todos/stats
  async getTodoStats(
    request: FastifyRequest,
    reply: FastifyReply
  ) {
    try {
      const stats = await this.todoService.getTodoStats();
      return this.sendSuccess(reply, stats);
    } catch (error) {
      throw error;
    }
  }
}
```

### Step 3: è·¯ç”±é‡æ§‹

```typescript
// apps/server/src/controllers/todos/todos.routes.ts
import { FastifyInstance } from 'fastify';
import { TodosController } from './todos.controller';
import { TodoService } from '../../services/todos/todos.service';
import { TodoRepository } from '../../repositories/todos/todos.repository';
import { validationMiddleware } from '../../middleware/validation/validation.middleware';
import { authMiddleware } from '../../middleware/auth/jwt.middleware';

// è·¯ç”±é¸é …é…ç½®
const routeOptions = {
  preHandler: [authMiddleware]  // æ‰€æœ‰è·¯ç”±éƒ½éœ€è¦èªè­‰
};

export async function todosRoutes(fastify: FastifyInstance) {
  // ä¾è³´æ³¨å…¥
  const todoRepository = new TodoRepository();
  const todoService = new TodoService(todoRepository);
  const todosController = new TodosController(todoService);

  // API è·¯ç”±ç¾¤çµ„
  await fastify.register(async function (fastify) {
    // GET /api/v1/todos - å–å¾—æ‰€æœ‰ todos
    fastify.get('/', {
      ...routeOptions,
      schema: {
        description: 'Get all todos with pagination and filtering',
        tags: ['Todos'],
        querystring: {
          type: 'object',
          properties: {
            page: { type: 'integer', minimum: 1, default: 1 },
            limit: { type: 'integer', minimum: 1, maximum: 100, default: 10 },
            author: { type: 'string' },
            isActive: { type: 'boolean' },
            search: { type: 'string' },
            sortBy: { 
              type: 'string', 
              enum: ['createdAt', 'updatedAt', 'content'],
              default: 'createdAt'
            },
            sortOrder: { 
              type: 'string', 
              enum: ['asc', 'desc'],
              default: 'desc'
            }
          }
        }
      }
    }, todosController.getAllTodos.bind(todosController));

    // GET /api/v1/todos/stats - å–å¾—çµ±è¨ˆè³‡è¨Š
    fastify.get('/stats', {
      ...routeOptions,
      schema: {
        description: 'Get todos statistics',
        tags: ['Todos']
      }
    }, todosController.getTodoStats.bind(todosController));

    // GET /api/v1/todos/:id - å–å¾—å–®ä¸€ todo
    fastify.get('/:id', {
      ...routeOptions,
      schema: {
        description: 'Get a specific todo by ID',
        tags: ['Todos'],
        params: {
          type: 'object',
          required: ['id'],
          properties: {
            id: { type: 'string', format: 'uuid' }
          }
        }
      }
    }, todosController.getTodoById.bind(todosController));

    // POST /api/v1/todos - å»ºç«‹æ–° todo
    fastify.post('/', {
      ...routeOptions,
      schema: {
        description: 'Create a new todo',
        tags: ['Todos'],
        body: {
          type: 'object',
          required: ['content', 'author'],
          properties: {
            content: { 
              type: 'string', 
              minLength: 1, 
              maxLength: 1000 
            },
            author: { 
              type: 'string', 
              minLength: 1, 
              maxLength: 100 
            }
          }
        }
      }
    }, todosController.createTodo.bind(todosController));

    // PUT /api/v1/todos/:id - æ›´æ–° todo
    fastify.put('/:id', {
      ...routeOptions,
      schema: {
        description: 'Update a todo',
        tags: ['Todos'],
        params: {
          type: 'object',
          required: ['id'],
          properties: {
            id: { type: 'string', format: 'uuid' }
          }
        },
        body: {
          type: 'object',
          properties: {
            content: { type: 'string', minLength: 1, maxLength: 1000 },
            author: { type: 'string', minLength: 1, maxLength: 100 },
            isActive: { type: 'boolean' }
          }
        }
      }
    }, todosController.updateTodo.bind(todosController));

    // PATCH /api/v1/todos/:id/status - åˆ‡æ› todo ç‹€æ…‹
    fastify.patch('/:id/status', {
      ...routeOptions,
      schema: {
        description: 'Toggle todo active status',
        tags: ['Todos'],
        params: {
          type: 'object',
          required: ['id'],
          properties: {
            id: { type: 'string', format: 'uuid' }
          }
        }
      }
    }, todosController.toggleTodoStatus.bind(todosController));

    // DELETE /api/v1/todos/:id - åˆªé™¤ todo
    fastify.delete('/:id', {
      ...routeOptions,
      schema: {
        description: 'Delete a todo',
        tags: ['Todos'],
        params: {
          type: 'object',
          required: ['id'],
          properties: {
            id: { type: 'string', format: 'uuid' }
          }
        }
      }
    }, todosController.deleteTodo.bind(todosController));
  }, { prefix: '/api/v1/todos' });
}
```

### Step 4: æœå‹™å±¤é‡æ§‹

```typescript
// apps/server/src/services/todos/todos.service.ts
import { BaseService } from '../base/base.service';
import { TodoRepository } from '../../repositories/todos/todos.repository';
import type { 
  CreateTodoRequest, 
  UpdateTodoRequest, 
  GetTodosOptions
} from './todos.types';
import type { Todo } from '@fastify-api/db';
import { NotFoundError, ValidationError } from '../../shared/errors/base';

export class TodoService extends BaseService {
  
  constructor(private todoRepository: TodoRepository) {
    super();
  }

  async getTodos(options: GetTodosOptions) {
    this.logger.info('Getting todos with options', options);
    
    const result = await this.todoRepository.findManyWithPagination(options);
    
    this.logger.info(`Retrieved ${result.data.length} todos`);
    return result;
  }

  async getTodoById(id: string): Promise<Todo> {
    this.logger.info(`Getting todo by id: ${id}`);
    
    await this.validateUUID(id);
    const todo = await this.todoRepository.findById(id);
    
    if (!todo) {
      throw new NotFoundError('Todo', id);
    }

    return todo;
  }

  async createTodo(data: CreateTodoRequest): Promise<Todo> {
    this.logger.info('Creating new todo', { author: data.author });
    
    // æ¥­å‹™é‚è¼¯é©—è­‰
    await this.validateCreateTodo(data);
    
    const newTodo = await this.todoRepository.create(data);
    
    this.logger.info(`Todo created with id: ${newTodo.id}`);
    return newTodo;
  }

  async updateTodo(id: string, data: UpdateTodoRequest): Promise<Todo> {
    this.logger.info(`Updating todo: ${id}`, data);
    
    await this.validateUUID(id);
    
    // æª¢æŸ¥æ˜¯å¦å­˜åœ¨
    const existingTodo = await this.getTodoById(id);
    
    // æ¥­å‹™é‚è¼¯é©—è­‰
    await this.validateUpdateTodo(data, existingTodo);
    
    const updatedTodo = await this.todoRepository.update(id, data);
    
    if (!updatedTodo) {
      throw new NotFoundError('Todo', id);
    }

    this.logger.info(`Todo updated: ${id}`);
    return updatedTodo;
  }

  async deleteTodo(id: string): Promise<void> {
    this.logger.info(`Deleting todo: ${id}`);
    
    await this.validateUUID(id);
    
    const success = await this.todoRepository.hardDelete(id);
    
    if (!success) {
      throw new NotFoundError('Todo', id);
    }

    this.logger.info(`Todo deleted: ${id}`);
  }

  async toggleTodoStatus(id: string): Promise<Todo> {
    this.logger.info(`Toggling todo status: ${id}`);
    
    const todo = await this.getTodoById(id);
    
    return await this.updateTodo(id, {
      isActive: !todo.isActive
    });
  }

  async getTodoStats() {
    this.logger.info('Getting todo statistics');
    
    const stats = await this.todoRepository.getStats();
    
    this.logger.info('Retrieved todo statistics', stats);
    return stats;
  }

  // ç§æœ‰é©—è­‰æ–¹æ³•
  private async validateCreateTodo(data: CreateTodoRequest): Promise<void> {
    // æª¢æŸ¥å…§å®¹é•·åº¦
    if (data.content.trim().length === 0) {
      throw new ValidationError('Content cannot be empty');
    }

    // æª¢æŸ¥æ˜¯å¦æœ‰é‡è¤‡å…§å®¹ (å¯é¸çš„æ¥­å‹™é‚è¼¯)
    const duplicateExists = await this.todoRepository.existsByAuthorAndContent(
      data.author, 
      data.content
    );

    if (duplicateExists) {
      throw new ValidationError(
        'Todo with similar content already exists for this author'
      );
    }
  }

  private async validateUpdateTodo(
    data: UpdateTodoRequest, 
    existingTodo: Todo
  ): Promise<void> {
    // æª¢æŸ¥æ˜¯å¦çœŸçš„æœ‰è®Šæ›´
    const hasChanges = Object.entries(data).some(([key, value]) => {
      return existingTodo[key as keyof Todo] !== value;
    });

    if (!hasChanges) {
      throw new ValidationError('No changes detected');
    }

    // å¦‚æœæ›´æ–°å…§å®¹ï¼Œæª¢æŸ¥é‡è¤‡
    if (data.content && data.content !== existingTodo.content) {
      const duplicateExists = await this.todoRepository.existsByAuthorAndContent(
        data.author || existingTodo.author,
        data.content,
        existingTodo.id // æ’é™¤è‡ªå·±
      );

      if (duplicateExists) {
        throw new ValidationError(
          'Todo with similar content already exists for this author'
        );
      }
    }
  }
}
```

### Step 5: åŸºç¤æœå‹™é¡

```typescript
// apps/server/src/services/base/base.service.ts
import { Logger } from 'pino';
import { ValidationError } from '../../shared/errors/base';
import { logger } from '../../shared/utils/logger';

export abstract class BaseService {
  protected logger: Logger;

  constructor() {
    this.logger = logger.child({ 
      service: this.constructor.name 
    });
  }

  protected async validateUUID(id: string): Promise<void> {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    
    if (!uuidRegex.test(id)) {
      throw new ValidationError('Invalid UUID format');
    }
  }

  protected validatePaginationParams(page: number, limit: number): void {
    if (page < 1) {
      throw new ValidationError('Page must be greater than 0');
    }

    if (limit < 1 || limit > 100) {
      throw new ValidationError('Limit must be between 1 and 100');
    }
  }

  protected sanitizeSearchTerm(term: string): string {
    return term.trim().toLowerCase();
  }

  protected logMethodEntry(methodName: string, params?: any): void {
    this.logger.debug(`Entering ${methodName}`, params);
  }

  protected logMethodExit(methodName: string, result?: any): void {
    this.logger.debug(`Exiting ${methodName}`, result);
  }
}
```

### Step 6: ä¸­ä»‹è»Ÿé«”ç³»çµ±

```typescript
// apps/server/src/middleware/validation/validation.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { ZodSchema } from 'zod';
import { ValidationError } from '../../shared/errors/base';

export const createValidationMiddleware = (schemas: {
  body?: ZodSchema;
  querystring?: ZodSchema;
  params?: ZodSchema;
}) => {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      if (schemas.body && request.body) {
        request.body = schemas.body.parse(request.body);
      }

      if (schemas.querystring && request.query) {
        request.query = schemas.querystring.parse(request.query);
      }

      if (schemas.params && request.params) {
        request.params = schemas.params.parse(request.params);
      }
    } catch (error) {
      throw new ValidationError('Validation failed', error);
    }
  };
};

// é€šç”¨é©—è­‰ä¸­ä»‹è»Ÿé«”
export const validationMiddleware = {
  validateBody: (schema: ZodSchema) => createValidationMiddleware({ body: schema }),
  validateQuery: (schema: ZodSchema) => createValidationMiddleware({ querystring: schema }),
  validateParams: (schema: ZodSchema) => createValidationMiddleware({ params: schema }),
  validateAll: (schemas: { body?: ZodSchema; querystring?: ZodSchema; params?: ZodSchema }) => 
    createValidationMiddleware(schemas)
};
```

### Step 7: ä¾è³´æ³¨å…¥å®¹å™¨

```typescript
// apps/server/src/shared/container/container.ts
export class Container {
  private services = new Map<string, any>();
  private factories = new Map<string, () => any>();

  register<T>(name: string, instance: T): void {
    this.services.set(name, instance);
  }

  registerFactory<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory);
  }

  resolve<T>(name: string): T {
    // å…ˆæª¢æŸ¥å·²è¨»å†Šçš„å¯¦ä¾‹
    if (this.services.has(name)) {
      return this.services.get(name);
    }

    // æª¢æŸ¥å·¥å» æ–¹æ³•
    if (this.factories.has(name)) {
      const factory = this.factories.get(name)!;
      const instance = factory();
      this.services.set(name, instance); // ç·©å­˜å¯¦ä¾‹
      return instance;
    }

    throw new Error(`Service ${name} not found in container`);
  }
}

// å…¨åŸŸå®¹å™¨å¯¦ä¾‹
export const container = new Container();

// æœå‹™è¨»å†Š
export const registerServices = () => {
  // è¨»å†Š Repository
  container.registerFactory('TodoRepository', () => new TodoRepository());
  
  // è¨»å†Š Service
  container.registerFactory('TodoService', () => 
    new TodoService(container.resolve('TodoRepository'))
  );
  
  // è¨»å†Š Controller
  container.registerFactory('TodosController', () => 
    new TodosController(container.resolve('TodoService'))
  );
};
```

---

## ğŸ§ª æ¸¬è©¦é‡æ§‹

### æ§åˆ¶å™¨å±¤æ¸¬è©¦

```typescript
// apps/server/src/test/controllers/todos.controller.test.ts
describe('TodosController', () => {
  let todoService: jest.Mocked<TodoService>;
  let todosController: TodosController;
  let mockRequest: Partial<FastifyRequest>;
  let mockReply: Partial<FastifyReply>;

  beforeEach(() => {
    todoService = {
      getTodos: jest.fn(),
      getTodoById: jest.fn(),
      createTodo: jest.fn(),
      updateTodo: jest.fn(),
      deleteTodo: jest.fn(),
      toggleTodoStatus: jest.fn(),
      getTodoStats: jest.fn()
    } as jest.Mocked<TodoService>;

    todosController = new TodosController(todoService);

    mockReply = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };
  });

  describe('getAllTodos', () => {
    it('should return paginated todos', async () => {
      const mockQuery = { page: 1, limit: 10 };
      const mockResult = {
        data: [],
        total: 0,
        page: 1,
        limit: 10,
        totalPages: 0,
        hasNext: false,
        hasPrev: false
      };

      mockRequest = { query: mockQuery };
      todoService.getTodos.mockResolvedValue(mockResult);

      await todosController.getAllTodos(
        mockRequest as FastifyRequest<{ Querystring: GetTodosQuery }>,
        mockReply as FastifyReply
      );

      expect(todoService.getTodos).toHaveBeenCalledWith({
        pagination: { page: 1, limit: 10 },
        filters: {},
        sort: { field: 'createdAt', order: 'desc' }
      });
      expect(mockReply.status).toHaveBeenCalledWith(200);
    });
  });
});
```

---

## âœ… å®Œæˆæ¨™æº–

### æ¶æ§‹éœ€æ±‚
- [x] Controller-Service-Repository åˆ†å±¤æ¶æ§‹å»ºç«‹
- [x] ä¾è³´æ³¨å…¥æ©Ÿåˆ¶å¯¦ç¾
- [x] çµ±ä¸€çš„ä¸­ä»‹è»Ÿé«”ç³»çµ±
- [x] æ¨¡çµ„åŒ–è·¯ç”±ç®¡ç†
- [x] åŸºç¤é¡åˆ¥æŠ½è±¡åŒ–

### ç¨‹å¼ç¢¼å“è³ª
- [x] å–®ä¸€è·è²¬åŸå‰‡å¯¦ç¾
- [x] é–‹æ”¾å°é–‰åŸå‰‡éµå¾ª
- [x] ä¾è³´åè½‰åŸå‰‡æ‡‰ç”¨
- [x] ä»‹é¢éš”é›¢åŸå‰‡å¯¦è¸
- [x] ç¨‹å¼ç¢¼é‡è¤‡æ€§é™ä½

### å¯ç¶­è­·æ€§
- [x] æ¸…æ™°çš„åˆ†å±¤ç•Œé™
- [x] å®¹æ˜“çš„å–®å…ƒæ¸¬è©¦
- [x] æ¨¡çµ„åŒ–çš„å…ƒä»¶è¨­è¨ˆ
- [x] ä¸€è‡´çš„éŒ¯èª¤è™•ç†
- [x] å®Œæ•´çš„æ—¥èªŒè¨˜éŒ„

---

## ğŸ“Š æ¶æ§‹å„ªå‹¢

### å¯ç¶­è­·æ€§æå‡
- æ¸…æ¥šçš„é—œæ³¨é»åˆ†é›¢
- é™ä½ç¨‹å¼ç¢¼è€¦åˆåº¦
- æé«˜ç¨‹å¼ç¢¼é‡ç”¨æ€§
- å®¹æ˜“é€²è¡Œå–®å…ƒæ¸¬è©¦

### å¯æ“´å±•æ€§å¢å¼·
- æ–°åŠŸèƒ½æ˜“æ–¼æ·»åŠ 
- æ¥­å‹™é‚è¼¯æ˜“æ–¼ä¿®æ”¹
- æ”¯æ´å¤šç¨®è³‡æ–™ä¾†æº
- å®¹æ˜“æ•´åˆç¬¬ä¸‰æ–¹æœå‹™

### é–‹ç™¼æ•ˆç‡
- ä¸€è‡´çš„é–‹ç™¼æ¨¡å¼
- æ¸›å°‘é‡è¤‡ç¨‹å¼ç¢¼
- åŠ é€Ÿæ–°åŠŸèƒ½é–‹ç™¼
- é™ä½ç¶­è­·æˆæœ¬