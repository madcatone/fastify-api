# TASK 5: Middleware ç³»çµ±å¯¦ç¾

## ğŸ“‹ ä»»å‹™æ¦‚è¿°

å»ºç«‹å®Œæ•´çš„ä¸­ä»‹è»Ÿé«”(Middleware)ç³»çµ±ï¼ŒåŒ…å«èªè­‰ã€æˆæ¬Šã€é©—è­‰ã€å®‰å…¨æ€§ã€æ—¥èªŒè¨˜éŒ„ç­‰åŠŸèƒ½ï¼Œæä¾›çµ±ä¸€çš„è«‹æ±‚è™•ç†ç®¡é“ã€‚

### ğŸ¯ ç›®æ¨™
- å¯¦ç¾å®Œæ•´çš„ä¸­ä»‹è»Ÿé«”ç®¡é“ç³»çµ±
- å»ºç«‹è«‹æ±‚/å›æ‡‰æ””æˆªæ©Ÿåˆ¶
- å¯¦ç¾çµ±ä¸€çš„éŒ¯èª¤è™•ç†ä¸­ä»‹è»Ÿé«”
- å»ºç«‹å®‰å…¨æ€§ä¸­ä»‹è»Ÿé«”çµ„ä»¶
- å¯¦ç¾è«‹æ±‚æ—¥èªŒå’Œç›£æ§ä¸­ä»‹è»Ÿé«”

### ğŸ“Š å‰ç½®æ¢ä»¶
- âœ… TASK 4: åˆ†å±¤æ¶æ§‹å·²é‡æ§‹å®Œæˆ
- âœ… åŸºç¤éŒ¯èª¤è™•ç†ç³»çµ±å·²å»ºç«‹
- âœ… æ—¥èªŒç³»çµ±å·²é…ç½®

---

## ğŸ—ï¸ Middleware æ¶æ§‹è¨­è¨ˆ

### ğŸ”„ è™•ç†ç®¡é“æµç¨‹

```
Request â†’ Security â†’ Auth â†’ Validation â†’ Business Logic â†’ Response
   â†“         â†“        â†“         â†“             â†“            â†“
CORS    â†’ JWT    â†’ Schema  â†’ Controller â†’ Service â†’ Formatted
Helmet  â†’ RBAC   â†’ Sanitize â†’ Params    â†’ Repo    â†’ Response
Rate    â†’ Session â†’ Transform â†’ Body     â†’ DB      â†’ Headers
Limit   â†’ Refresh â†’          â†’ Query    â†’         â†’ Status
```

### ğŸ“ Middleware æª”æ¡ˆçµæ§‹

```
apps/server/src/middleware/
â”œâ”€â”€ auth/                     # èªè­‰ç›¸é—œä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ jwt.middleware.ts     # JWT é©—è­‰
â”‚   â”œâ”€â”€ session.middleware.ts # Session ç®¡ç†
â”‚   â”œâ”€â”€ refresh.middleware.ts # Token åˆ·æ–°
â”‚   â””â”€â”€ rbac.middleware.ts    # è§’è‰²æ¬Šé™æ§åˆ¶
â”œâ”€â”€ security/                 # å®‰å…¨æ€§ä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ cors.middleware.ts    # CORS è¨­å®š
â”‚   â”œâ”€â”€ helmet.middleware.ts  # å®‰å…¨æ¨™é ­
â”‚   â”œâ”€â”€ rate-limit.middleware.ts # è«‹æ±‚é »ç‡é™åˆ¶
â”‚   â”œâ”€â”€ csrf.middleware.ts    # CSRF ä¿è­·
â”‚   â””â”€â”€ sanitizer.middleware.ts # è¼¸å…¥æ¸…ç†
â”œâ”€â”€ validation/               # é©—è­‰ä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ schema.middleware.ts  # Schema é©—è­‰
â”‚   â”œâ”€â”€ transform.middleware.ts # è³‡æ–™è½‰æ›
â”‚   â””â”€â”€ file-upload.middleware.ts # æª”æ¡ˆä¸Šå‚³é©—è­‰
â”œâ”€â”€ logging/                  # æ—¥èªŒä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ request.middleware.ts # è«‹æ±‚æ—¥èªŒ
â”‚   â”œâ”€â”€ response.middleware.ts # å›æ‡‰æ—¥èªŒ
â”‚   â”œâ”€â”€ error.middleware.ts   # éŒ¯èª¤æ—¥èªŒ
â”‚   â””â”€â”€ performance.middleware.ts # æ•ˆèƒ½ç›£æ§
â”œâ”€â”€ cache/                    # å¿«å–ä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ redis.middleware.ts   # Redis å¿«å–
â”‚   â”œâ”€â”€ memory.middleware.ts  # è¨˜æ†¶é«”å¿«å–
â”‚   â””â”€â”€ etag.middleware.ts    # ETag å¿«å–
â”œâ”€â”€ utils/                    # å·¥å…·ä¸­ä»‹è»Ÿé«”
â”‚   â”œâ”€â”€ compression.middleware.ts # å£“ç¸®
â”‚   â”œâ”€â”€ timeout.middleware.ts # è«‹æ±‚è¶…æ™‚
â”‚   â””â”€â”€ health.middleware.ts  # å¥åº·æª¢æŸ¥
â””â”€â”€ index.ts                  # ä¸­ä»‹è»Ÿé«”çµ±ä¸€å°å‡º
```

---

## ğŸ”¨ å¯¦æ–½æ­¥é©Ÿ

### Step 1: åŸºç¤ä¸­ä»‹è»Ÿé«”ä»‹é¢

```typescript
// apps/server/src/middleware/base/types.ts
import { FastifyRequest, FastifyReply } from 'fastify';

export interface MiddlewareContext {
  startTime: number;
  requestId: string;
  user?: any;
  permissions?: string[];
  metadata?: Record<string, any>;
}

export type MiddlewareHandler = (
  request: FastifyRequest,
  reply: FastifyReply
) => Promise<void> | void;

export interface MiddlewareOptions {
  enabled?: boolean;
  skipRoutes?: string[];
  onlyRoutes?: string[];
  config?: Record<string, any>;
}

export abstract class BaseMiddleware {
  constructor(protected options: MiddlewareOptions = {}) {}

  abstract handle(request: FastifyRequest, reply: FastifyReply): Promise<void> | void;

  protected shouldSkip(request: FastifyRequest): boolean {
    const route = request.routerPath;
    
    if (this.options.onlyRoutes && !this.options.onlyRoutes.includes(route)) {
      return true;
    }
    
    if (this.options.skipRoutes && this.options.skipRoutes.includes(route)) {
      return true;
    }
    
    return !this.options.enabled;
  }
}
```

### Step 2: JWT èªè­‰ä¸­ä»‹è»Ÿé«”

```typescript
// apps/server/src/middleware/auth/jwt.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import jwt from 'jsonwebtoken';
import { BaseMiddleware } from '../base/types';
import { UnauthorizedError, ForbiddenError } from '../../shared/errors/auth.errors';

export interface JwtPayload {
  userId: string;
  email: string;
  roles: string[];
  permissions: string[];
  iat: number;
  exp: number;
}

export interface JwtMiddlewareOptions extends MiddlewareOptions {
  secret: string;
  algorithms?: string[];
  skipRefreshCheck?: boolean;
  requirePermissions?: string[];
}

export class JwtMiddleware extends BaseMiddleware {
  constructor(private jwtOptions: JwtMiddlewareOptions) {
    super(jwtOptions);
  }

  async handle(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    if (this.shouldSkip(request)) {
      return;
    }

    try {
      // æå– Token
      const token = this.extractToken(request);
      
      if (!token) {
        throw new UnauthorizedError('Missing authentication token');
      }

      // é©—è­‰ Token
      const payload = await this.verifyToken(token);
      
      // æª¢æŸ¥æ¬Šé™
      if (this.jwtOptions.requirePermissions) {
        this.checkPermissions(payload, this.jwtOptions.requirePermissions);
      }

      // è¨­å®šä½¿ç”¨è€…è³‡è¨Šåˆ°è«‹æ±‚ç‰©ä»¶
      request.user = {
        id: payload.userId,
        email: payload.email,
        roles: payload.roles,
        permissions: payload.permissions
      };

      // æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
      request.context = {
        ...request.context,
        user: request.user,
        permissions: payload.permissions
      };

    } catch (error) {
      if (error instanceof jwt.JsonWebTokenError) {
        throw new UnauthorizedError('Invalid authentication token');
      }
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Authentication token expired');
      }
      throw error;
    }
  }

  private extractToken(request: FastifyRequest): string | null {
    const authHeader = request.headers.authorization;
    
    if (!authHeader) {
      return null;
    }

    const parts = authHeader.split(' ');
    if (parts.length !== 2 || parts[0] !== 'Bearer') {
      return null;
    }

    return parts[1];
  }

  private async verifyToken(token: string): Promise<JwtPayload> {
    return new Promise((resolve, reject) => {
      jwt.verify(
        token,
        this.jwtOptions.secret,
        {
          algorithms: this.jwtOptions.algorithms || ['HS256']
        },
        (err, decoded) => {
          if (err) {
            reject(err);
          } else {
            resolve(decoded as JwtPayload);
          }
        }
      );
    });
  }

  private checkPermissions(payload: JwtPayload, requiredPermissions: string[]): void {
    const userPermissions = payload.permissions || [];
    
    const hasAllPermissions = requiredPermissions.every(permission =>
      userPermissions.includes(permission)
    );

    if (!hasAllPermissions) {
      throw new ForbiddenError('Insufficient permissions');
    }
  }
}

// ä¾¿åˆ©å‡½æ•¸
export const createJwtMiddleware = (options: JwtMiddlewareOptions) => {
  const middleware = new JwtMiddleware(options);
  return middleware.handle.bind(middleware);
};
```

### Step 3: è§’è‰²æ¬Šé™æ§åˆ¶ä¸­ä»‹è»Ÿé«”

```typescript
// apps/server/src/middleware/auth/rbac.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { BaseMiddleware } from '../base/types';
import { ForbiddenError } from '../../shared/errors/auth.errors';

export interface RbacRule {
  resource: string;
  action: string;
  roles?: string[];
  permissions?: string[];
  condition?: (user: any, request: FastifyRequest) => boolean;
}

export interface RbacMiddlewareOptions extends MiddlewareOptions {
  rules: RbacRule[];
  defaultDeny?: boolean;
}

export class RbacMiddleware extends BaseMiddleware {
  constructor(private rbacOptions: RbacMiddlewareOptions) {
    super(rbacOptions);
  }

  async handle(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    if (this.shouldSkip(request)) {
      return;
    }

    const user = request.user;
    if (!user) {
      throw new ForbiddenError('User not authenticated');
    }

    const { resource, action } = this.extractResourceAction(request);
    const applicableRules = this.findApplicableRules(resource, action);

    if (applicableRules.length === 0) {
      if (this.rbacOptions.defaultDeny) {
        throw new ForbiddenError('Access denied - no applicable rules');
      }
      return;
    }

    const hasAccess = applicableRules.some(rule => 
      this.checkRule(rule, user, request)
    );

    if (!hasAccess) {
      throw new ForbiddenError(`Access denied to ${resource}:${action}`);
    }
  }

  private extractResourceAction(request: FastifyRequest): { resource: string; action: string } {
    // å¾è·¯ç”±è·¯å¾‘å’Œ HTTP æ–¹æ³•æå–è³‡æºå’Œå‹•ä½œ
    const method = request.method.toLowerCase();
    const path = request.routerPath || request.url;
    
    // ç¤ºä¾‹ï¼š/api/v1/todos -> resource: todos, action: æ ¹æ“š HTTP æ–¹æ³•æ±ºå®š
    const pathParts = path.split('/').filter(Boolean);
    const resource = pathParts[pathParts.length - 1] || 'unknown';
    
    const actionMap: Record<string, string> = {
      get: 'read',
      post: 'create',
      put: 'update',
      patch: 'update',
      delete: 'delete'
    };

    return {
      resource,
      action: actionMap[method] || method
    };
  }

  private findApplicableRules(resource: string, action: string): RbacRule[] {
    return this.rbacOptions.rules.filter(rule =>
      (rule.resource === '*' || rule.resource === resource) &&
      (rule.action === '*' || rule.action === action)
    );
  }

  private checkRule(rule: RbacRule, user: any, request: FastifyRequest): boolean {
    // æª¢æŸ¥è§’è‰²
    if (rule.roles && !rule.roles.some(role => user.roles.includes(role))) {
      return false;
    }

    // æª¢æŸ¥æ¬Šé™
    if (rule.permissions && !rule.permissions.some(perm => user.permissions.includes(perm))) {
      return false;
    }

    // æª¢æŸ¥è‡ªå®šç¾©æ¢ä»¶
    if (rule.condition && !rule.condition(user, request)) {
      return false;
    }

    return true;
  }
}

// é å®šç¾©è¦å‰‡
export const defaultRbacRules: RbacRule[] = [
  {
    resource: 'todos',
    action: 'read',
    permissions: ['todos:read']
  },
  {
    resource: 'todos',
    action: 'create',
    permissions: ['todos:create']
  },
  {
    resource: 'todos',
    action: 'update',
    permissions: ['todos:update'],
    condition: (user, request) => {
      // åªå…è¨±æ›´æ–°è‡ªå·±çš„ todos
      const todoAuthor = request.body?.author;
      return !todoAuthor || todoAuthor === user.email;
    }
  },
  {
    resource: 'todos',
    action: 'delete',
    roles: ['admin'],
    permissions: ['todos:delete']
  }
];
```

### Step 4: å®‰å…¨æ€§ä¸­ä»‹è»Ÿé«”

```typescript
// apps/server/src/middleware/security/helmet.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { BaseMiddleware } from '../base/types';

export interface HelmetOptions extends MiddlewareOptions {
  contentSecurityPolicy?: {
    directives?: Record<string, string[]>;
    useDefaults?: boolean;
  };
  hsts?: {
    maxAge?: number;
    includeSubDomains?: boolean;
    preload?: boolean;
  };
  noSniff?: boolean;
  frameguard?: {
    action?: 'deny' | 'sameorigin' | 'allow-from';
    domain?: string;
  };
  xssFilter?: boolean;
}

export class HelmetMiddleware extends BaseMiddleware {
  constructor(private helmetOptions: HelmetOptions) {
    super(helmetOptions);
  }

  async handle(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    if (this.shouldSkip(request)) {
      return;
    }

    // Content Security Policy
    if (this.helmetOptions.contentSecurityPolicy !== false) {
      this.setCSPHeaders(reply);
    }

    // HTTP Strict Transport Security
    if (this.helmetOptions.hsts !== false) {
      this.setHSTSHeaders(reply);
    }

    // X-Content-Type-Options
    if (this.helmetOptions.noSniff !== false) {
      reply.header('X-Content-Type-Options', 'nosniff');
    }

    // X-Frame-Options
    if (this.helmetOptions.frameguard !== false) {
      this.setFrameguardHeaders(reply);
    }

    // X-XSS-Protection
    if (this.helmetOptions.xssFilter !== false) {
      reply.header('X-XSS-Protection', '1; mode=block');
    }

    // å…¶ä»–å®‰å…¨æ¨™é ­
    reply.header('X-Permitted-Cross-Domain-Policies', 'none');
    reply.header('Referrer-Policy', 'no-referrer');
    reply.header('Cross-Origin-Embedder-Policy', 'require-corp');
    reply.header('Cross-Origin-Opener-Policy', 'same-origin');
    reply.header('Cross-Origin-Resource-Policy', 'same-origin');
  }

  private setCSPHeaders(reply: FastifyReply): void {
    const options = this.helmetOptions.contentSecurityPolicy || {};
    const directives = {
      'default-src': ["'self'"],
      'script-src': ["'self'"],
      'style-src': ["'self'", "'unsafe-inline'"],
      'img-src': ["'self'", 'data:', 'https:'],
      'font-src': ["'self'"],
      'object-src': ["'none'"],
      'base-uri': ["'self'"],
      'form-action': ["'self'"],
      'frame-ancestors': ["'none'"],
      'upgrade-insecure-requests': [],
      ...options.directives
    };

    const cspValue = Object.entries(directives)
      .map(([directive, sources]) => 
        `${directive} ${sources.join(' ')}`
      )
      .join('; ');

    reply.header('Content-Security-Policy', cspValue);
  }

  private setHSTSHeaders(reply: FastifyReply): void {
    const options = this.helmetOptions.hsts || {};
    const maxAge = options.maxAge || 31536000; // 1 year
    
    let value = `max-age=${maxAge}`;
    
    if (options.includeSubDomains !== false) {
      value += '; includeSubDomains';
    }
    
    if (options.preload) {
      value += '; preload';
    }

    reply.header('Strict-Transport-Security', value);
  }

  private setFrameguardHeaders(reply: FastifyReply): void {
    const options = this.helmetOptions.frameguard || {};
    const action = options.action || 'deny';
    
    if (action === 'allow-from' && options.domain) {
      reply.header('X-Frame-Options', `ALLOW-FROM ${options.domain}`);
    } else {
      reply.header('X-Frame-Options', action.toUpperCase());
    }
  }
}
```

### Step 5: è«‹æ±‚é »ç‡é™åˆ¶ä¸­ä»‹è»Ÿé«”

```typescript
// apps/server/src/middleware/security/rate-limit.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { BaseMiddleware } from '../base/types';
import { TooManyRequestsError } from '../../shared/errors/rate-limit.errors';

export interface RateLimitOptions extends MiddlewareOptions {
  windowMs: number;        // æ™‚é–“çª—å£ (æ¯«ç§’)
  max: number;            // æœ€å¤§è«‹æ±‚æ•¸
  keyGenerator?: (request: FastifyRequest) => string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  store?: RateLimitStore;
  onLimitReached?: (request: FastifyRequest) => void;
}

export interface RateLimitStore {
  increment(key: string): Promise<{ totalHits: number; timeToExpire: number }>;
  decrement(key: string): Promise<void>;
  resetKey(key: string): Promise<void>;
}

export class MemoryRateLimitStore implements RateLimitStore {
  private store = new Map<string, { count: number; resetTime: number }>();

  async increment(key: string): Promise<{ totalHits: number; timeToExpire: number }> {
    const now = Date.now();
    const current = this.store.get(key);

    if (!current || now > current.resetTime) {
      // æ–°çš„æ™‚é–“çª—å£
      const resetTime = now + 60000; // 1 åˆ†é˜çª—å£
      this.store.set(key, { count: 1, resetTime });
      return { totalHits: 1, timeToExpire: resetTime - now };
    }

    // ç¾æœ‰æ™‚é–“çª—å£
    current.count++;
    this.store.set(key, current);
    return { totalHits: current.count, timeToExpire: current.resetTime - now };
  }

  async decrement(key: string): Promise<void> {
    const current = this.store.get(key);
    if (current && current.count > 0) {
      current.count--;
      this.store.set(key, current);
    }
  }

  async resetKey(key: string): Promise<void> {
    this.store.delete(key);
  }
}

export class RateLimitMiddleware extends BaseMiddleware {
  private store: RateLimitStore;

  constructor(private rateLimitOptions: RateLimitOptions) {
    super(rateLimitOptions);
    this.store = rateLimitOptions.store || new MemoryRateLimitStore();
  }

  async handle(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    if (this.shouldSkip(request)) {
      return;
    }

    const key = this.generateKey(request);
    const { totalHits, timeToExpire } = await this.store.increment(key);

    // è¨­å®šå›æ‡‰æ¨™é ­
    reply.header('X-RateLimit-Limit', this.rateLimitOptions.max);
    reply.header('X-RateLimit-Remaining', Math.max(0, this.rateLimitOptions.max - totalHits));
    reply.header('X-RateLimit-Reset', new Date(Date.now() + timeToExpire).toISOString());

    if (totalHits > this.rateLimitOptions.max) {
      // è§¸ç™¼é™åˆ¶å›èª¿
      if (this.rateLimitOptions.onLimitReached) {
        this.rateLimitOptions.onLimitReached(request);
      }

      // è¨­å®š Retry-After æ¨™é ­
      reply.header('Retry-After', Math.ceil(timeToExpire / 1000));

      throw new TooManyRequestsError(
        'Too many requests from this IP, please try again later'
      );
    }

    // éŒ¯èª¤è™•ç† - å¦‚æœè«‹æ±‚å¤±æ•—ä¸”é…ç½®ä¸è¨ˆç®—å¤±æ•—è«‹æ±‚ï¼Œå‰‡æ¸›å°‘è¨ˆæ•¸
    reply.addHook('onError', async (request, reply, error) => {
      if (this.rateLimitOptions.skipFailedRequests) {
        await this.store.decrement(key);
      }
    });
  }

  private generateKey(request: FastifyRequest): string {
    if (this.rateLimitOptions.keyGenerator) {
      return this.rateLimitOptions.keyGenerator(request);
    }

    // é è¨­ä½¿ç”¨ IP åœ°å€
    const ip = request.ip || 
               request.headers['x-forwarded-for'] || 
               request.headers['x-real-ip'] || 
               'unknown';
    
    return `rate_limit:${ip}`;
  }
}

// é è¨­é…ç½®
export const createRateLimitMiddleware = (options: Partial<RateLimitOptions> = {}) => {
  const defaultOptions: RateLimitOptions = {
    windowMs: 15 * 60 * 1000, // 15 åˆ†é˜
    max: 100,                  // æ¯å€‹ IP æœ€å¤š 100 å€‹è«‹æ±‚
    enabled: true,
    ...options
  };

  const middleware = new RateLimitMiddleware(defaultOptions);
  return middleware.handle.bind(middleware);
};
```

### Step 6: è«‹æ±‚æ—¥èªŒä¸­ä»‹è»Ÿé«”

```typescript
// apps/server/src/middleware/logging/request.middleware.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { BaseMiddleware } from '../base/types';
import { logger } from '../../shared/utils/logger';
import { v4 as uuidv4 } from 'uuid';

export interface RequestLoggingOptions extends MiddlewareOptions {
  includeHeaders?: boolean;
  includeBody?: boolean;
  includeQuery?: boolean;
  sensitiveFields?: string[];
  maxBodySize?: number;
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
}

export class RequestLoggingMiddleware extends BaseMiddleware {
  constructor(private loggingOptions: RequestLoggingOptions) {
    super(loggingOptions);
  }

  async handle(request: FastifyRequest, reply: FastifyReply): Promise<void> {
    if (this.shouldSkip(request)) {
      return;
    }

    // ç”Ÿæˆè«‹æ±‚ ID
    const requestId = uuidv4();
    request.id = requestId;

    // è¨˜éŒ„è«‹æ±‚é–‹å§‹æ™‚é–“
    const startTime = Date.now();
    request.startTime = startTime;

    // æº–å‚™æ—¥èªŒè³‡æ–™
    const logData: any = {
      requestId,
      method: request.method,
      url: request.url,
      userAgent: request.headers['user-agent'],
      ip: request.ip,
      timestamp: new Date().toISOString()
    };

    // åŒ…å«æ¨™é ­
    if (this.loggingOptions.includeHeaders) {
      logData.headers = this.sanitizeHeaders(request.headers);
    }

    // åŒ…å«æŸ¥è©¢åƒæ•¸
    if (this.loggingOptions.includeQuery && request.query) {
      logData.query = this.sanitizeData(request.query);
    }

    // åŒ…å«è«‹æ±‚ä¸»é«”
    if (this.loggingOptions.includeBody && request.body) {
      logData.body = this.sanitizeBody(request.body);
    }

    // è¨˜éŒ„è«‹æ±‚
    logger.info(logData, 'Incoming request');

    // è¨­å®šå›æ‡‰ hook
    reply.addHook('onSend', async (request, reply, payload) => {
      const duration = Date.now() - startTime;
      
      const responseLogData = {
        requestId,
        statusCode: reply.statusCode,
        duration,
        responseSize: this.getPayloadSize(payload),
        timestamp: new Date().toISOString()
      };

      // æ ¹æ“šç‹€æ…‹ç¢¼æ±ºå®šæ—¥èªŒç­‰ç´š
      const logLevel = reply.statusCode >= 500 ? 'error' :
                       reply.statusCode >= 400 ? 'warn' : 'info';

      logger[logLevel](responseLogData, 'Request completed');
    });

    // è¨­å®šéŒ¯èª¤ hook
    reply.addHook('onError', async (request, reply, error) => {
      const duration = Date.now() - startTime;
      
      logger.error({
        requestId,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name
        },
        duration,
        timestamp: new Date().toISOString()
      }, 'Request failed');
    });
  }

  private sanitizeHeaders(headers: any): any {
    const sanitized = { ...headers };
    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key'];
    
    sensitiveHeaders.forEach(header => {
      if (sanitized[header]) {
        sanitized[header] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  private sanitizeData(data: any): any {
    if (!data || typeof data !== 'object') {
      return data;
    }

    const sanitized = { ...data };
    const sensitiveFields = this.loggingOptions.sensitiveFields || 
                           ['password', 'token', 'secret', 'key', 'auth'];

    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  private sanitizeBody(body: any): any {
    // æª¢æŸ¥å¤§å°é™åˆ¶
    const maxSize = this.loggingOptions.maxBodySize || 1024; // 1KB
    const bodyString = JSON.stringify(body);
    
    if (bodyString.length > maxSize) {
      return { _truncated: true, _size: bodyString.length };
    }

    return this.sanitizeData(body);
  }

  private getPayloadSize(payload: any): number {
    if (typeof payload === 'string') {
      return Buffer.byteLength(payload, 'utf8');
    }
    if (Buffer.isBuffer(payload)) {
      return payload.length;
    }
    if (payload) {
      return Buffer.byteLength(JSON.stringify(payload), 'utf8');
    }
    return 0;
  }
}
```

### Step 7: ä¸­ä»‹è»Ÿé«”è¨»å†Šç³»çµ±

```typescript
// apps/server/src/middleware/index.ts
import { FastifyInstance } from 'fastify';
import { createJwtMiddleware } from './auth/jwt.middleware';
import { RbacMiddleware, defaultRbacRules } from './auth/rbac.middleware';
import { HelmetMiddleware } from './security/helmet.middleware';
import { createRateLimitMiddleware } from './security/rate-limit.middleware';
import { RequestLoggingMiddleware } from './logging/request.middleware';
import { config } from '../config';

export interface MiddlewareConfig {
  auth: {
    jwt: {
      enabled: boolean;
      secret: string;
      skipRoutes?: string[];
    };
    rbac: {
      enabled: boolean;
      rules?: any[];
    };
  };
  security: {
    helmet: { enabled: boolean };
    rateLimit: {
      enabled: boolean;
      windowMs?: number;
      max?: number;
    };
    cors: { enabled: boolean };
  };
  logging: {
    requests: {
      enabled: boolean;
      includeBody?: boolean;
    };
  };
}

export class MiddlewareManager {
  constructor(private config: MiddlewareConfig) {}

  async registerAll(fastify: FastifyInstance): Promise<void> {
    // å®‰å…¨æ€§ä¸­ä»‹è»Ÿé«” (æœ€å…ˆåŸ·è¡Œ)
    await this.registerSecurityMiddleware(fastify);
    
    // æ—¥èªŒä¸­ä»‹è»Ÿé«”
    await this.registerLoggingMiddleware(fastify);
    
    // èªè­‰ä¸­ä»‹è»Ÿé«”
    await this.registerAuthMiddleware(fastify);
    
    // æ¥­å‹™é‚è¼¯ä¸­ä»‹è»Ÿé«”
    await this.registerBusinessMiddleware(fastify);
  }

  private async registerSecurityMiddleware(fastify: FastifyInstance): Promise<void> {
    // Helmet (å®‰å…¨æ¨™é ­)
    if (this.config.security.helmet.enabled) {
      const helmetMiddleware = new HelmetMiddleware({
        enabled: true,
        skipRoutes: ['/health', '/metrics']
      });
      
      fastify.addHook('onRequest', helmetMiddleware.handle.bind(helmetMiddleware));
    }

    // Rate Limiting
    if (this.config.security.rateLimit.enabled) {
      const rateLimitMiddleware = createRateLimitMiddleware({
        windowMs: this.config.security.rateLimit.windowMs,
        max: this.config.security.rateLimit.max,
        skipRoutes: ['/health', '/metrics']
      });
      
      fastify.addHook('onRequest', rateLimitMiddleware);
    }

    // CORS
    if (this.config.security.cors.enabled) {
      await fastify.register(require('@fastify/cors'), {
        origin: (origin, callback) => {
          // å…è¨±çš„ä¾†æºé‚è¼¯
          const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];
          
          if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
          } else {
            callback(new Error('Not allowed by CORS'), false);
          }
        },
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
      });
    }
  }

  private async registerLoggingMiddleware(fastify: FastifyInstance): Promise<void> {
    if (this.config.logging.requests.enabled) {
      const requestLoggingMiddleware = new RequestLoggingMiddleware({
        enabled: true,
        includeBody: this.config.logging.requests.includeBody,
        includeHeaders: false,
        includeQuery: true,
        sensitiveFields: ['password', 'token', 'secret'],
        maxBodySize: 2048,
        skipRoutes: ['/health', '/metrics']
      });
      
      fastify.addHook('onRequest', requestLoggingMiddleware.handle.bind(requestLoggingMiddleware));
    }
  }

  private async registerAuthMiddleware(fastify: FastifyInstance): Promise<void> {
    // JWT èªè­‰
    if (this.config.auth.jwt.enabled) {
      const jwtMiddleware = createJwtMiddleware({
        enabled: true,
        secret: this.config.auth.jwt.secret,
        skipRoutes: [
          '/health',
          '/metrics',
          '/auth/login',
          '/auth/register',
          '/docs',
          '/docs/*'
        ]
      });
      
      // åªåœ¨éœ€è¦èªè­‰çš„è·¯ç”±ä¸Šæ·»åŠ 
      fastify.addHook('onRequest', async (request, reply) => {
        const skipRoutes = this.config.auth.jwt.skipRoutes || [];
        const shouldSkip = skipRoutes.some(route => {
          if (route.endsWith('/*')) {
            return request.url.startsWith(route.slice(0, -2));
          }
          return request.url === route;
        });
        
        if (!shouldSkip) {
          await jwtMiddleware(request, reply);
        }
      });
    }

    // RBAC æˆæ¬Š
    if (this.config.auth.rbac.enabled) {
      const rbacMiddleware = new RbacMiddleware({
        enabled: true,
        rules: this.config.auth.rbac.rules || defaultRbacRules,
        defaultDeny: false,
        skipRoutes: ['/health', '/metrics', '/auth/*', '/docs', '/docs/*']
      });
      
      fastify.addHook('preHandler', rbacMiddleware.handle.bind(rbacMiddleware));
    }
  }

  private async registerBusinessMiddleware(fastify: FastifyInstance): Promise<void> {
    // è³‡æ–™å£“ç¸®
    await fastify.register(require('@fastify/compress'), {
      global: true,
      threshold: 1024
    });

    // æª”æ¡ˆä¸Šå‚³è™•ç†
    await fastify.register(require('@fastify/multipart'), {
      limits: {
        fieldNameSize: 100,
        fieldSize: 100,
        fields: 10,
        fileSize: 1000000, // 1MB
        files: 1,
        headerPairs: 2000
      }
    });
  }
}

// é è¨­é…ç½®
export const defaultMiddlewareConfig: MiddlewareConfig = {
  auth: {
    jwt: {
      enabled: true,
      secret: process.env.JWT_SECRET || 'your-secret-key'
    },
    rbac: {
      enabled: true
    }
  },
  security: {
    helmet: { enabled: true },
    rateLimit: {
      enabled: true,
      windowMs: 15 * 60 * 1000, // 15 åˆ†é˜
      max: 100 // æ¯å€‹ IP 100 å€‹è«‹æ±‚
    },
    cors: { enabled: true }
  },
  logging: {
    requests: {
      enabled: true,
      includeBody: false
    }
  }
};

// ä¾¿åˆ©å‡½æ•¸
export const registerMiddleware = async (
  fastify: FastifyInstance, 
  config: Partial<MiddlewareConfig> = {}
) => {
  const finalConfig = { ...defaultMiddlewareConfig, ...config };
  const manager = new MiddlewareManager(finalConfig);
  await manager.registerAll(fastify);
};
```

---

## ğŸ§ª æ¸¬è©¦ç­–ç•¥

### ä¸­ä»‹è»Ÿé«”å–®å…ƒæ¸¬è©¦

```typescript
// apps/server/src/test/middleware/jwt.middleware.test.ts
describe('JwtMiddleware', () => {
  let jwtMiddleware: JwtMiddleware;
  let mockRequest: Partial<FastifyRequest>;
  let mockReply: Partial<FastifyReply>;

  beforeEach(() => {
    jwtMiddleware = new JwtMiddleware({
      enabled: true,
      secret: 'test-secret'
    });

    mockReply = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };
  });

  it('should authenticate valid JWT token', async () => {
    const token = jwt.sign(
      { userId: '123', email: 'test@example.com', roles: [], permissions: [] },
      'test-secret'
    );

    mockRequest = {
      headers: { authorization: `Bearer ${token}` },
      user: undefined
    };

    await jwtMiddleware.handle(
      mockRequest as FastifyRequest,
      mockReply as FastifyReply
    );

    expect(mockRequest.user).toBeDefined();
    expect(mockRequest.user.id).toBe('123');
  });

  it('should reject invalid JWT token', async () => {
    mockRequest = {
      headers: { authorization: 'Bearer invalid-token' }
    };

    await expect(
      jwtMiddleware.handle(
        mockRequest as FastifyRequest,
        mockReply as FastifyReply
      )
    ).rejects.toThrow(UnauthorizedError);
  });
});
```

---

## âœ… å®Œæˆæ¨™æº–

### åŠŸèƒ½éœ€æ±‚
- [x] å®Œæ•´çš„èªè­‰å’Œæˆæ¬Šä¸­ä»‹è»Ÿé«”
- [x] å®‰å…¨æ€§ä¸­ä»‹è»Ÿé«”å¥—ä»¶
- [x] è«‹æ±‚/å›æ‡‰æ—¥èªŒè¨˜éŒ„
- [x] é »ç‡é™åˆ¶æ©Ÿåˆ¶
- [x] éŒ¯èª¤è™•ç†ä¸­ä»‹è»Ÿé«”

### å®‰å…¨éœ€æ±‚
- [x] JWT token é©—è­‰
- [x] è§’è‰²æ¬Šé™æ§åˆ¶ (RBAC)
- [x] å®‰å…¨æ¨™é ­è¨­å®š
- [x] CORS ä¿è­·
- [x] è«‹æ±‚é »ç‡é™åˆ¶

### å¯è§€å¯Ÿæ€§
- [x] çµæ§‹åŒ–æ—¥èªŒè¨˜éŒ„
- [x] è«‹æ±‚è¿½è¹¤å’Œç›£æ§
- [x] æ•ˆèƒ½æŒ‡æ¨™æ”¶é›†
- [x] éŒ¯èª¤è¿½è¹¤

---

## ğŸ“Š æ•ˆèƒ½æŒ‡æ¨™

- ä¸­ä»‹è»Ÿé«”è™•ç†æ™‚é–“: < 5ms
- è¨˜æ†¶é«”ä½¿ç”¨å¢é‡: < 50MB
- æ—¥èªŒå¯«å…¥å»¶é²: < 10ms
- èªè­‰é©—è­‰æ™‚é–“: < 20ms
- æ¬Šé™æª¢æŸ¥æ™‚é–“: < 5ms