# TASK 6: å®Œæ•´æ¸¬è©¦å¥—ä»¶

## ğŸ“‹ ä»»å‹™æ¦‚è¿°

å»ºç«‹å®Œæ•´çš„æ¸¬è©¦å¥—ä»¶ï¼ŒåŒ…å«å–®å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦ã€ç«¯å°ç«¯æ¸¬è©¦ï¼Œç¢ºä¿ç¨‹å¼ç¢¼å“è³ªå’Œç³»çµ±ç©©å®šæ€§ã€‚

### ğŸ¯ ç›®æ¨™
- å»ºç«‹å®Œæ•´çš„æ¸¬è©¦æ¡†æ¶å’Œé…ç½®
- å¯¦ç¾é«˜è¦†è“‹ç‡çš„å–®å…ƒæ¸¬è©¦
- å»ºç«‹ API æ•´åˆæ¸¬è©¦
- å¯¦ç¾ç«¯å°ç«¯ (E2E) æ¸¬è©¦
- å»ºç«‹æ¸¬è©¦è³‡æ–™ç®¡ç†æ©Ÿåˆ¶
- å¯¦ç¾æŒçºŒæ¸¬è©¦å’Œå ±å‘Šç”Ÿæˆ

### ğŸ“Š å‰ç½®æ¢ä»¶
- âœ… TASK 5: Middleware ç³»çµ±å·²å¯¦ç¾
- âœ… åˆ†å±¤æ¶æ§‹å·²å®Œæˆ
- âœ… API ç«¯é»å·²å»ºç«‹

---

## ğŸ—ï¸ æ¸¬è©¦æ¶æ§‹è¨­è¨ˆ

### ğŸ”„ æ¸¬è©¦é‡‘å­—å¡”

```
    E2E Tests (ç«¯å°ç«¯æ¸¬è©¦)
   â†—               â†–
  Integration Tests (æ•´åˆæ¸¬è©¦)
 â†—                         â†–
Unit Tests (å–®å…ƒæ¸¬è©¦ - æœ€å¤š)
```

### ğŸ“ æ¸¬è©¦æª”æ¡ˆçµæ§‹

```
apps/server/src/test/
â”œâ”€â”€ config/                    # æ¸¬è©¦é…ç½®
â”‚   â”œâ”€â”€ setup.ts              # æ¸¬è©¦ç’°å¢ƒè¨­å®š
â”‚   â”œâ”€â”€ teardown.ts           # æ¸¬è©¦æ¸…ç†
â”‚   â”œâ”€â”€ database.ts           # æ¸¬è©¦è³‡æ–™åº«é…ç½®
â”‚   â””â”€â”€ fixtures.ts           # æ¸¬è©¦è³‡æ–™ Fixtures
â”œâ”€â”€ unit/                     # å–®å…ƒæ¸¬è©¦
â”‚   â”œâ”€â”€ controllers/          # æ§åˆ¶å™¨æ¸¬è©¦
â”‚   â”‚   â”œâ”€â”€ todos.controller.test.ts
â”‚   â”‚   â””â”€â”€ base.controller.test.ts
â”‚   â”œâ”€â”€ services/             # æœå‹™æ¸¬è©¦
â”‚   â”‚   â”œâ”€â”€ todos.service.test.ts
â”‚   â”‚   â””â”€â”€ base.service.test.ts
â”‚   â”œâ”€â”€ repositories/         # Repository æ¸¬è©¦
â”‚   â”‚   â”œâ”€â”€ todos.repository.test.ts
â”‚   â”‚   â””â”€â”€ base.repository.test.ts
â”‚   â”œâ”€â”€ middleware/           # ä¸­ä»‹è»Ÿé«”æ¸¬è©¦
â”‚   â”‚   â”œâ”€â”€ auth.middleware.test.ts
â”‚   â”‚   â”œâ”€â”€ validation.middleware.test.ts
â”‚   â”‚   â””â”€â”€ security.middleware.test.ts
â”‚   â””â”€â”€ utils/               # å·¥å…·å‡½æ•¸æ¸¬è©¦
â”‚       â”œâ”€â”€ validation.test.ts
â”‚       â”œâ”€â”€ response.test.ts
â”‚       â””â”€â”€ pagination.test.ts
â”œâ”€â”€ integration/             # æ•´åˆæ¸¬è©¦
â”‚   â”œâ”€â”€ api/                # API æ•´åˆæ¸¬è©¦
â”‚   â”‚   â”œâ”€â”€ todos.api.test.ts
â”‚   â”‚   â”œâ”€â”€ auth.api.test.ts
â”‚   â”‚   â””â”€â”€ health.api.test.ts
â”‚   â”œâ”€â”€ database/           # è³‡æ–™åº«æ•´åˆæ¸¬è©¦
â”‚   â”‚   â”œâ”€â”€ todos.db.test.ts
â”‚   â”‚   â””â”€â”€ migrations.test.ts
â”‚   â””â”€â”€ middleware/         # ä¸­ä»‹è»Ÿé«”æ•´åˆæ¸¬è©¦
â”‚       â”œâ”€â”€ auth-flow.test.ts
â”‚       â””â”€â”€ security-flow.test.ts
â”œâ”€â”€ e2e/                    # ç«¯å°ç«¯æ¸¬è©¦
â”‚   â”œâ”€â”€ scenarios/          # æ¸¬è©¦å ´æ™¯
â”‚   â”‚   â”œâ”€â”€ todo-crud.e2e.test.ts
â”‚   â”‚   â”œâ”€â”€ auth-flow.e2e.test.ts
â”‚   â”‚   â””â”€â”€ user-journey.e2e.test.ts
â”‚   â””â”€â”€ support/           # E2E æ”¯æ´æª”æ¡ˆ
â”‚       â”œâ”€â”€ api-client.ts
â”‚       â””â”€â”€ test-data.ts
â”œâ”€â”€ mocks/                 # Mock è³‡æ–™å’Œå‡½æ•¸
â”‚   â”œâ”€â”€ database.mock.ts
â”‚   â”œâ”€â”€ external-apis.mock.ts
â”‚   â””â”€â”€ middleware.mock.ts
â”œâ”€â”€ utils/                 # æ¸¬è©¦å·¥å…·
â”‚   â”œâ”€â”€ test-server.ts     # æ¸¬è©¦ä¼ºæœå™¨è¨­å®š
â”‚   â”œâ”€â”€ database-helper.ts # è³‡æ–™åº«æ¸¬è©¦è¼”åŠ©
â”‚   â”œâ”€â”€ auth-helper.ts     # èªè­‰æ¸¬è©¦è¼”åŠ©
â”‚   â””â”€â”€ assertion-helper.ts # è‡ªå®šç¾©æ–·è¨€
â””â”€â”€ coverage/              # è¦†è“‹ç‡å ±å‘Š
    â”œâ”€â”€ lcov.info
    â””â”€â”€ html/
```

---

## ğŸ”¨ å¯¦æ–½æ­¥é©Ÿ

### Step 1: æ¸¬è©¦é…ç½®å’Œè¨­å®š

```typescript
// apps/server/src/test/config/setup.ts
import { beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { FastifyInstance } from 'fastify';
import { db } from '@fastify-api/db';
import { createTestServer } from '../utils/test-server';
import { setupTestDatabase, cleanTestDatabase } from '../utils/database-helper';
import { logger } from '../../shared/utils/logger';

// å…¨åŸŸæ¸¬è©¦è¨­å®š
export interface TestContext {
  server: FastifyInstance;
  database: typeof db;
  userTokens: Map<string, string>;
}

export const testContext: TestContext = {
  server: null as any,
  database: db,
  userTokens: new Map()
};

// æ¸¬è©¦å¥—ä»¶è¨­å®š
beforeAll(async () => {
  // è¨­å®šæ¸¬è©¦æ—¥èªŒç­‰ç´š
  logger.level = 'error';

  // å»ºç«‹æ¸¬è©¦ä¼ºæœå™¨
  testContext.server = await createTestServer();

  // è¨­å®šæ¸¬è©¦è³‡æ–™åº«
  await setupTestDatabase();

  console.log('âœ… Test environment setup completed');
});

// æ¸¬è©¦å¥—ä»¶æ¸…ç†
afterAll(async () => {
  if (testContext.server) {
    await testContext.server.close();
  }
  
  await cleanTestDatabase();
  console.log('âœ… Test environment cleanup completed');
});

// æ¯å€‹æ¸¬è©¦å‰çš„è¨­å®š
beforeEach(async () => {
  // æ¸…ç†è³‡æ–™åº«
  await cleanTestDatabase();
  
  // é‡è¨­ mock
  vi.clearAllMocks();
});

// æ¯å€‹æ¸¬è©¦å¾Œçš„æ¸…ç†
afterEach(async () => {
  // ç¢ºä¿æ²’æœ‰æ®˜ç•™çš„å®šæ™‚å™¨æˆ–éåŒæ­¥æ“ä½œ
  vi.clearAllTimers();
});

// å…¨åŸŸ Mock è¨­å®š
vi.mock('../../shared/utils/logger', () => ({
  logger: {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    child: vi.fn(() => ({
      info: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
      debug: vi.fn()
    }))
  }
}));
```

```typescript
// apps/server/src/test/utils/test-server.ts
import Fastify, { FastifyInstance } from 'fastify';
import { registerMiddleware } from '../../middleware';
import { todosRoutes } from '../../controllers/todos/todos.routes';
import { authRoutes } from '../../controllers/auth/auth.routes';

export async function createTestServer(): Promise<FastifyInstance> {
  const server = Fastify({
    logger: false // åœ¨æ¸¬è©¦ä¸­é—œé–‰æ—¥èªŒ
  });

  // è¨»å†Šä¸­ä»‹è»Ÿé«” (æ¸¬è©¦é…ç½®)
  await registerMiddleware(server, {
    auth: {
      jwt: {
        enabled: true,
        secret: 'test-jwt-secret',
        skipRoutes: ['/health', '/auth/login', '/auth/register']
      },
      rbac: {
        enabled: false // åœ¨æ¸¬è©¦ä¸­ç°¡åŒ–æ¬Šé™æ§åˆ¶
      }
    },
    security: {
      helmet: { enabled: false },
      rateLimit: { enabled: false },
      cors: { enabled: false }
    },
    logging: {
      requests: { enabled: false }
    }
  });

  // è¨»å†Šè·¯ç”±
  await server.register(todosRoutes);
  await server.register(authRoutes);

  // å¥åº·æª¢æŸ¥ç«¯é»
  server.get('/health', async () => ({ status: 'ok' }));

  return server;
}
```

### Step 2: æ¸¬è©¦è³‡æ–™ç®¡ç†

```typescript
// apps/server/src/test/utils/database-helper.ts
import { db, todos } from '@fastify-api/db';
import { faker } from '@faker-js/faker';
import type { Todo, NewTodo } from '@fastify-api/db';

export async function setupTestDatabase(): Promise<void> {
  // ç¢ºä¿æ¸¬è©¦è³‡æ–™åº«é€£æ¥æ­£å¸¸
  try {
    await db.select().from(todos).limit(1);
  } catch (error) {
    console.error('Failed to connect to test database:', error);
    throw error;
  }
}

export async function cleanTestDatabase(): Promise<void> {
  // æ¸…ç†æ‰€æœ‰æ¸¬è©¦è³‡æ–™
  await db.delete(todos);
}

// æ¸¬è©¦è³‡æ–™ç”Ÿæˆå™¨
export class TestDataGenerator {
  static createTodoData(overrides: Partial<NewTodo> = {}): NewTodo {
    return {
      content: faker.lorem.sentence(),
      author: faker.internet.email(),
      ...overrides
    };
  }

  static createTodosData(count: number, overrides: Partial<NewTodo> = {}): NewTodo[] {
    return Array.from({ length: count }, () => this.createTodoData(overrides));
  }

  static async createTodo(overrides: Partial<NewTodo> = {}): Promise<Todo> {
    const todoData = this.createTodoData(overrides);
    const [todo] = await db.insert(todos).values(todoData).returning();
    return todo;
  }

  static async createTodos(count: number, overrides: Partial<NewTodo> = {}): Promise<Todo[]> {
    const todosData = this.createTodosData(count, overrides);
    return await db.insert(todos).values(todosData).returning();
  }

  static async createTodosForAuthor(author: string, count: number): Promise<Todo[]> {
    return await this.createTodos(count, { author });
  }
}

// è³‡æ–™åº«æ–·è¨€è¼”åŠ©
export class DatabaseAssertions {
  static async assertTodoExists(id: string): Promise<Todo> {
    const [todo] = await db.select().from(todos).where(eq(todos.id, id));
    expect(todo).toBeDefined();
    return todo;
  }

  static async assertTodoNotExists(id: string): Promise<void> {
    const [todo] = await db.select().from(todos).where(eq(todos.id, id));
    expect(todo).toBeUndefined();
  }

  static async assertTodoCount(expectedCount: number): Promise<void> {
    const [{ count }] = await db.select({ count: count() }).from(todos);
    expect(count).toBe(expectedCount);
  }

  static async assertActiveTodoCount(expectedCount: number): Promise<void> {
    const [{ count }] = await db
      .select({ count: count() })
      .from(todos)
      .where(eq(todos.isActive, true));
    expect(count).toBe(expectedCount);
  }
}
```

### Step 3: èªè­‰æ¸¬è©¦è¼”åŠ©

```typescript
// apps/server/src/test/utils/auth-helper.ts
import jwt from 'jsonwebtoken';
import { FastifyInstance } from 'fastify';

export interface TestUser {
  id: string;
  email: string;
  roles: string[];
  permissions: string[];
}

export class AuthTestHelper {
  private jwtSecret: string;

  constructor(jwtSecret: string = 'test-jwt-secret') {
    this.jwtSecret = jwtSecret;
  }

  createTestUser(overrides: Partial<TestUser> = {}): TestUser {
    return {
      id: '550e8400-e29b-41d4-a716-446655440000',
      email: 'test@example.com',
      roles: ['user'],
      permissions: ['todos:read', 'todos:create', 'todos:update'],
      ...overrides
    };
  }

  createAdminUser(overrides: Partial<TestUser> = {}): TestUser {
    return this.createTestUser({
      email: 'admin@example.com',
      roles: ['admin', 'user'],
      permissions: [
        'todos:read',
        'todos:create', 
        'todos:update',
        'todos:delete',
        'users:manage'
      ],
      ...overrides
    });
  }

  generateToken(user: TestUser, expiresIn: string = '1h'): string {
    return jwt.sign(
      {
        userId: user.id,
        email: user.email,
        roles: user.roles,
        permissions: user.permissions
      },
      this.jwtSecret,
      { expiresIn }
    );
  }

  generateExpiredToken(user: TestUser): string {
    return jwt.sign(
      {
        userId: user.id,
        email: user.email,
        roles: user.roles,
        permissions: user.permissions
      },
      this.jwtSecret,
      { expiresIn: '-1h' } // å·²éæœŸ
    );
  }

  createAuthHeaders(token: string): Record<string, string> {
    return {
      'authorization': `Bearer ${token}`
    };
  }

  async authenticatedRequest(
    server: FastifyInstance,
    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE',
    url: string,
    user: TestUser = this.createTestUser(),
    payload?: any
  ) {
    const token = this.generateToken(user);
    const headers = this.createAuthHeaders(token);

    const options: any = {
      method,
      url,
      headers
    };

    if (payload && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      options.payload = payload;
    }

    return await server.inject(options);
  }
}
```

### Step 4: å–®å…ƒæ¸¬è©¦ç¯„ä¾‹

```typescript
// apps/server/src/test/unit/controllers/todos.controller.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { TodosController } from '../../../controllers/todos/todos.controller';
import { TodoService } from '../../../services/todos/todos.service';
import { TestDataGenerator } from '../../utils/database-helper';
import { createMockRequest, createMockReply } from '../../mocks/fastify.mock';

describe('TodosController', () => {
  let todosController: TodosController;
  let todoService: vi.Mocked<TodoService>;

  beforeEach(() => {
    // å»ºç«‹ Service Mock
    todoService = {
      getTodos: vi.fn(),
      getTodoById: vi.fn(),
      createTodo: vi.fn(),
      updateTodo: vi.fn(),
      deleteTodo: vi.fn(),
      toggleTodoStatus: vi.fn(),
      getTodoStats: vi.fn()
    } as any;

    todosController = new TodosController(todoService);
  });

  describe('getAllTodos', () => {
    it('should return paginated todos successfully', async () => {
      // Arrange
      const mockQuery = { page: 1, limit: 10 };
      const mockTodos = await TestDataGenerator.createTodos(5);
      const mockResult = {
        data: mockTodos,
        total: 5,
        page: 1,
        limit: 10,
        totalPages: 1,
        hasNext: false,
        hasPrev: false
      };

      const request = createMockRequest({ query: mockQuery });
      const reply = createMockReply();

      todoService.getTodos.mockResolvedValue(mockResult);

      // Act
      await todosController.getAllTodos(request, reply);

      // Assert
      expect(todoService.getTodos).toHaveBeenCalledWith({
        pagination: { page: 1, limit: 10 },
        filters: {},
        sort: { field: 'createdAt', order: 'desc' }
      });
      expect(reply.status).toHaveBeenCalledWith(200);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: expect.objectContaining({
          items: mockTodos,
          pagination: expect.any(Object)
        })
      });
    });

    it('should handle validation errors', async () => {
      // Arrange
      const request = createMockRequest({ 
        query: { page: -1, limit: 101 } // ç„¡æ•ˆçš„åˆ†é åƒæ•¸
      });
      const reply = createMockReply();

      // Act & Assert
      await expect(
        todosController.getAllTodos(request, reply)
      ).rejects.toThrow();
    });
  });

  describe('createTodo', () => {
    it('should create todo successfully', async () => {
      // Arrange
      const todoData = TestDataGenerator.createTodoData();
      const createdTodo = { ...todoData, id: '123', createdAt: new Date(), updatedAt: new Date(), isActive: true };
      
      const request = createMockRequest({ body: todoData });
      const reply = createMockReply();

      todoService.createTodo.mockResolvedValue(createdTodo);

      // Act
      await todosController.createTodo(request, reply);

      // Assert
      expect(todoService.createTodo).toHaveBeenCalledWith(todoData);
      expect(reply.status).toHaveBeenCalledWith(201);
      expect(reply.send).toHaveBeenCalledWith({
        success: true,
        data: createdTodo
      });
    });

    it('should handle service errors', async () => {
      // Arrange
      const todoData = TestDataGenerator.createTodoData();
      const request = createMockRequest({ body: todoData });
      const reply = createMockReply();

      todoService.createTodo.mockRejectedValue(new Error('Service error'));

      // Act & Assert
      await expect(
        todosController.createTodo(request, reply)
      ).rejects.toThrow('Service error');
    });
  });
});
```

### Step 5: æ•´åˆæ¸¬è©¦ç¯„ä¾‹

```typescript
// apps/server/src/test/integration/api/todos.api.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { testContext } from '../../config/setup';
import { TestDataGenerator, DatabaseAssertions } from '../../utils/database-helper';
import { AuthTestHelper } from '../../utils/auth-helper';

describe('Todos API Integration Tests', () => {
  let authHelper: AuthTestHelper;
  let testUser: any;

  beforeEach(async () => {
    authHelper = new AuthTestHelper();
    testUser = authHelper.createTestUser();
  });

  describe('GET /api/v1/todos', () => {
    it('should return empty list when no todos exist', async () => {
      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'GET',
        '/api/v1/todos',
        testUser
      );

      // Assert
      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.items).toHaveLength(0);
      expect(body.data.pagination.total).toBe(0);
    });

    it('should return paginated todos', async () => {
      // Arrange
      const todos = await TestDataGenerator.createTodos(15);

      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'GET',
        '/api/v1/todos?page=1&limit=10',
        testUser
      );

      // Assert
      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.items).toHaveLength(10);
      expect(body.data.pagination.total).toBe(15);
      expect(body.data.pagination.hasNext).toBe(true);
    });

    it('should filter todos by author', async () => {
      // Arrange
      await TestDataGenerator.createTodosForAuthor('user1@test.com', 3);
      await TestDataGenerator.createTodosForAuthor('user2@test.com', 2);

      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'GET',
        '/api/v1/todos?author=user1@test.com',
        testUser
      );

      // Assert
      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.data.items).toHaveLength(3);
      body.data.items.forEach((todo: any) => {
        expect(todo.author).toBe('user1@test.com');
      });
    });

    it('should return 401 when not authenticated', async () => {
      // Act
      const response = await testContext.server.inject({
        method: 'GET',
        url: '/api/v1/todos'
      });

      // Assert
      expect(response.statusCode).toBe(401);
    });
  });

  describe('POST /api/v1/todos', () => {
    it('should create todo successfully', async () => {
      // Arrange
      const todoData = TestDataGenerator.createTodoData();

      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'POST',
        '/api/v1/todos',
        testUser,
        todoData
      );

      // Assert
      expect(response.statusCode).toBe(201);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(true);
      expect(body.data.content).toBe(todoData.content);
      expect(body.data.author).toBe(todoData.author);
      expect(body.data.id).toBeDefined();

      // é©—è­‰è³‡æ–™åº«
      await DatabaseAssertions.assertTodoExists(body.data.id);
    });

    it('should validate required fields', async () => {
      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'POST',
        '/api/v1/todos',
        testUser,
        { content: '' } // ç¼ºå°‘ authorï¼Œcontent ç‚ºç©º
      );

      // Assert
      expect(response.statusCode).toBe(400);
      const body = JSON.parse(response.body);
      expect(body.success).toBe(false);
      expect(body.error).toContain('Validation failed');
    });
  });

  describe('PUT /api/v1/todos/:id', () => {
    it('should update todo successfully', async () => {
      // Arrange
      const todo = await TestDataGenerator.createTodo();
      const updateData = { content: 'Updated content' };

      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'PUT',
        `/api/v1/todos/${todo.id}`,
        testUser,
        updateData
      );

      // Assert
      expect(response.statusCode).toBe(200);
      const body = JSON.parse(response.body);
      expect(body.data.content).toBe(updateData.content);
      expect(body.data.updatedAt).not.toBe(todo.updatedAt);

      // é©—è­‰è³‡æ–™åº«
      const updatedTodo = await DatabaseAssertions.assertTodoExists(todo.id);
      expect(updatedTodo.content).toBe(updateData.content);
    });

    it('should return 404 for non-existent todo', async () => {
      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'PUT',
        '/api/v1/todos/550e8400-e29b-41d4-a716-446655440000',
        testUser,
        { content: 'Updated' }
      );

      // Assert
      expect(response.statusCode).toBe(404);
    });
  });

  describe('DELETE /api/v1/todos/:id', () => {
    it('should delete todo successfully', async () => {
      // Arrange
      const todo = await TestDataGenerator.createTodo();

      // Act
      const response = await authHelper.authenticatedRequest(
        testContext.server,
        'DELETE',
        `/api/v1/todos/${todo.id}`,
        testUser
      );

      // Assert
      expect(response.statusCode).toBe(204);

      // é©—è­‰è³‡æ–™åº«
      await DatabaseAssertions.assertTodoNotExists(todo.id);
    });
  });
});
```

### Step 6: E2E æ¸¬è©¦ç¯„ä¾‹

```typescript
// apps/server/src/test/e2e/scenarios/todo-crud.e2e.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { testContext } from '../../config/setup';
import { AuthTestHelper } from '../../utils/auth-helper';

describe('Todo CRUD E2E Flow', () => {
  let authHelper: AuthTestHelper;
  let testUser: any;
  let authHeaders: Record<string, string>;

  beforeEach(async () => {
    authHelper = new AuthTestHelper();
    testUser = authHelper.createTestUser();
    const token = authHelper.generateToken(testUser);
    authHeaders = authHelper.createAuthHeaders(token);
  });

  it('should complete full todo lifecycle', async () => {
    const server = testContext.server;

    // 1. åˆå§‹ç‹€æ…‹ - æ²’æœ‰ todos
    const initialResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos',
      headers: authHeaders
    });

    expect(initialResponse.statusCode).toBe(200);
    const initialBody = JSON.parse(initialResponse.body);
    expect(initialBody.data.items).toHaveLength(0);

    // 2. å»ºç«‹ç¬¬ä¸€å€‹ todo
    const todo1Data = {
      content: 'Complete API documentation',
      author: testUser.email
    };

    const createResponse1 = await server.inject({
      method: 'POST',
      url: '/api/v1/todos',
      headers: authHeaders,
      payload: todo1Data
    });

    expect(createResponse1.statusCode).toBe(201);
    const createdTodo1 = JSON.parse(createResponse1.body).data;

    // 3. å»ºç«‹ç¬¬äºŒå€‹ todo
    const todo2Data = {
      content: 'Write unit tests',
      author: testUser.email
    };

    const createResponse2 = await server.inject({
      method: 'POST',
      url: '/api/v1/todos',
      headers: authHeaders,
      payload: todo2Data
    });

    expect(createResponse2.statusCode).toBe(201);
    const createdTodo2 = JSON.parse(createResponse2.body).data;

    // 4. é©—è­‰åˆ—è¡¨åŒ…å«å…©å€‹ todos
    const listResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos',
      headers: authHeaders
    });

    expect(listResponse.statusCode).toBe(200);
    const listBody = JSON.parse(listResponse.body);
    expect(listBody.data.items).toHaveLength(2);

    // 5. æ›´æ–°ç¬¬ä¸€å€‹ todo
    const updateData = {
      content: 'Complete API documentation with examples',
      isActive: false
    };

    const updateResponse = await server.inject({
      method: 'PUT',
      url: `/api/v1/todos/${createdTodo1.id}`,
      headers: authHeaders,
      payload: updateData
    });

    expect(updateResponse.statusCode).toBe(200);
    const updatedTodo = JSON.parse(updateResponse.body).data;
    expect(updatedTodo.content).toBe(updateData.content);
    expect(updatedTodo.isActive).toBe(false);

    // 6. åˆ‡æ›ç¬¬äºŒå€‹ todo çš„ç‹€æ…‹
    const toggleResponse = await server.inject({
      method: 'PATCH',
      url: `/api/v1/todos/${createdTodo2.id}/status`,
      headers: authHeaders
    });

    expect(toggleResponse.statusCode).toBe(200);
    const toggledTodo = JSON.parse(toggleResponse.body).data;
    expect(toggledTodo.isActive).toBe(false); // å¾é è¨­çš„ true è®Šç‚º false

    // 7. ç¯©é¸åªé¡¯ç¤ºæ´»èºçš„ todos
    const activeFilterResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos?isActive=true',
      headers: authHeaders
    });

    expect(activeFilterResponse.statusCode).toBe(200);
    const activeBody = JSON.parse(activeFilterResponse.body);
    expect(activeBody.data.items).toHaveLength(0); // å…©å€‹éƒ½è¢«è¨­ç‚ºéæ´»èº

    // 8. æœå°‹åŠŸèƒ½æ¸¬è©¦
    const searchResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos?search=documentation',
      headers: authHeaders
    });

    expect(searchResponse.statusCode).toBe(200);
    const searchBody = JSON.parse(searchResponse.body);
    expect(searchBody.data.items).toHaveLength(1);
    expect(searchBody.data.items[0].content).toContain('documentation');

    // 9. å–å¾—çµ±è¨ˆè³‡è¨Š
    const statsResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos/stats',
      headers: authHeaders
    });

    expect(statsResponse.statusCode).toBe(200);
    const statsBody = JSON.parse(statsResponse.body);
    expect(statsBody.data.total).toBe(2);
    expect(statsBody.data.active).toBe(0);
    expect(statsBody.data.inactive).toBe(2);

    // 10. åˆªé™¤ä¸€å€‹ todo
    const deleteResponse = await server.inject({
      method: 'DELETE',
      url: `/api/v1/todos/${createdTodo1.id}`,
      headers: authHeaders
    });

    expect(deleteResponse.statusCode).toBe(204);

    // 11. é©—è­‰åˆªé™¤å¾Œçš„ç‹€æ…‹
    const finalListResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos',
      headers: authHeaders
    });

    expect(finalListResponse.statusCode).toBe(200);
    const finalBody = JSON.parse(finalListResponse.body);
    expect(finalBody.data.items).toHaveLength(1);
    expect(finalBody.data.items[0].id).toBe(createdTodo2.id);

    // 12. å˜—è©¦å–å¾—å·²åˆªé™¤çš„ todo (æ‡‰è©²è¿”å› 404)
    const getDeletedResponse = await server.inject({
      method: 'GET',
      url: `/api/v1/todos/${createdTodo1.id}`,
      headers: authHeaders
    });

    expect(getDeletedResponse.statusCode).toBe(404);
  });

  it('should handle error scenarios gracefully', async () => {
    const server = testContext.server;

    // 1. ç„¡æ•ˆçš„ UUID æ ¼å¼
    const invalidUuidResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos/invalid-uuid',
      headers: authHeaders
    });

    expect(invalidUuidResponse.statusCode).toBe(400);

    // 2. ä¸å­˜åœ¨çš„ todo
    const notFoundResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos/550e8400-e29b-41d4-a716-446655440000',
      headers: authHeaders
    });

    expect(notFoundResponse.statusCode).toBe(404);

    // 3. ç„¡æ•ˆçš„è«‹æ±‚ä¸»é«”
    const invalidBodyResponse = await server.inject({
      method: 'POST',
      url: '/api/v1/todos',
      headers: authHeaders,
      payload: { content: '' } // ç©ºå…§å®¹
    });

    expect(invalidBodyResponse.statusCode).toBe(400);

    // 4. æœªèªè­‰çš„è«‹æ±‚
    const unauthenticatedResponse = await server.inject({
      method: 'GET',
      url: '/api/v1/todos'
      // æ²’æœ‰ headers
    });

    expect(unauthenticatedResponse.statusCode).toBe(401);
  });
});
```

### Step 7: æ¸¬è©¦è…³æœ¬å’Œé…ç½®

```typescript
// vitest.config.ts (æ›´æ–°)
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: ['./src/test/config/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'dist/',
        'coverage/',
        '**/*.d.ts',
        'vitest.config.ts',
        'src/test/**/*',
        '**/*.test.ts',
        '**/*.spec.ts'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    },
    testTimeout: 10000,
    hookTimeout: 10000,
    teardownTimeout: 5000,
    // æ¸¬è©¦åˆ†é¡
    include: [
      'src/test/**/*.test.ts',
      'src/test/**/*.spec.ts'
    ],
    // æ¸¬è©¦ä¸¦è¡Œé…ç½®
    threads: true,
    maxThreads: 4,
    minThreads: 1,
    // é‡è©¦æ©Ÿåˆ¶
    retry: 1,
    // ç›£è¦–æ¨¡å¼æ’é™¤
    watchExclude: [
      '**/node_modules/**',
      '**/dist/**',
      '**/coverage/**'
    ]
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@db': path.resolve(__dirname, '../../packages/db/src'),
    }
  }
});
```

```json
// package.json (æ›´æ–°æ¸¬è©¦è…³æœ¬)
{
  "scripts": {
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest watch",
    "test:unit": "vitest run src/test/unit",
    "test:integration": "vitest run src/test/integration",
    "test:e2e": "vitest run src/test/e2e",
    "test:ci": "vitest run --coverage --reporter=verbose --reporter=junit --outputFile=test-results.xml",
    "test:debug": "vitest --inspect-brk --no-coverage",
    "test:ui": "vitest --ui"
  }
}
```

---

## ğŸ§ª æ¸¬è©¦ç­–ç•¥å’Œæœ€ä½³å¯¦è¸

### å–®å…ƒæ¸¬è©¦æŒ‡å°åŸå‰‡
- **å–®ä¸€è·è²¬**: æ¯å€‹æ¸¬è©¦åªé©—è­‰ä¸€å€‹åŠŸèƒ½é»
- **ç¨ç«‹æ€§**: æ¸¬è©¦ä¹‹é–“ä¸æ‡‰è©²æœ‰ä¾è³´é—œä¿‚
- **å¯é‡è¤‡æ€§**: æ¸¬è©¦çµæœæ‡‰è©²ä¸€è‡´ä¸”å¯é‡ç¾
- **å¿«é€ŸåŸ·è¡Œ**: å–®å…ƒæ¸¬è©¦æ‡‰è©²åœ¨å¹¾æ¯«ç§’å…§å®Œæˆ

### æ•´åˆæ¸¬è©¦æŒ‡å°åŸå‰‡
- **çœŸå¯¦ç’°å¢ƒ**: ä½¿ç”¨çœŸå¯¦çš„è³‡æ–™åº«å’Œå¤–éƒ¨æœå‹™
- **ç«¯åˆ°ç«¯æµç¨‹**: æ¸¬è©¦å®Œæ•´çš„ API è«‹æ±‚/å›æ‡‰æµç¨‹
- **è³‡æ–™æ¸…ç†**: ç¢ºä¿æ¯å€‹æ¸¬è©¦éƒ½æœ‰ä¹¾æ·¨çš„è³‡æ–™ç’°å¢ƒ
- **éŒ¯èª¤å ´æ™¯**: æ¸¬è©¦å„ç¨®éŒ¯èª¤å’Œé‚Šç•Œæƒ…æ³

### E2E æ¸¬è©¦æŒ‡å°åŸå‰‡
- **ç”¨æˆ¶å ´æ™¯**: æ¨¡æ“¬çœŸå¯¦ç”¨æˆ¶çš„å®Œæ•´æ“ä½œæµç¨‹
- **é—œéµè·¯å¾‘**: å°ˆæ³¨æ–¼æœ€é‡è¦çš„æ¥­å‹™æµç¨‹
- **ç©©å®šæ€§**: æ¸›å°‘å¤–éƒ¨ä¾è³´å’Œéš¨æ©Ÿæ€§
- **å¯ç¶­è­·æ€§**: ä½¿ç”¨é é¢ç‰©ä»¶æ¨¡å¼çµ„ç¹”æ¸¬è©¦ç¨‹å¼ç¢¼

---

## âœ… å®Œæˆæ¨™æº–

### æ¸¬è©¦è¦†è“‹ç‡éœ€æ±‚
- **æ•´é«”è¦†è“‹ç‡**: â‰¥ 80%
- **åˆ†æ”¯è¦†è“‹ç‡**: â‰¥ 80% 
- **å‡½æ•¸è¦†è“‹ç‡**: â‰¥ 80%
- **è¡Œè¦†è“‹ç‡**: â‰¥ 80%

### æ¸¬è©¦åˆ†é¡éœ€æ±‚
- [x] å–®å…ƒæ¸¬è©¦ (Unit Tests) - è¦†è“‹æ‰€æœ‰æ¥­å‹™é‚è¼¯
- [x] æ•´åˆæ¸¬è©¦ (Integration Tests) - è¦†è“‹ API ç«¯é»
- [x] E2E æ¸¬è©¦ (End-to-End Tests) - è¦†è“‹é—œéµç”¨æˆ¶æµç¨‹
- [x] æ•ˆèƒ½æ¸¬è©¦åŸºç¤æ¶æ§‹
- [x] å®‰å…¨æ¸¬è©¦åŸºç¤æª¢æŸ¥

### å“è³ªä¿è­‰éœ€æ±‚
- [x] è‡ªå‹•åŒ–æ¸¬è©¦åŸ·è¡Œ
- [x] æŒçºŒæ•´åˆé…ç½®
- [x] æ¸¬è©¦å ±å‘Šç”Ÿæˆ
- [x] éŒ¯èª¤å ´æ™¯è¦†è“‹
- [x] æ¸¬è©¦è³‡æ–™ç®¡ç†

---

## ğŸ“Š æ¸¬è©¦æŒ‡æ¨™ç›£æ§

### æ•ˆèƒ½æŒ‡æ¨™
- æ¸¬è©¦åŸ·è¡Œæ™‚é–“: å–®å…ƒæ¸¬è©¦ < 30sï¼Œæ•´åˆæ¸¬è©¦ < 2minï¼ŒE2E æ¸¬è©¦ < 5min
- è¨˜æ†¶é«”ä½¿ç”¨é‡: < 512MB åœ¨æ¸¬è©¦åŸ·è¡ŒæœŸé–“
- è³‡æ–™åº«æ“ä½œå»¶é²: < 100ms å¹³å‡å›æ‡‰æ™‚é–“

### å“è³ªæŒ‡æ¨™
- æ¸¬è©¦æˆåŠŸç‡: â‰¥ 99%
- ç¨‹å¼ç¢¼è¦†è“‹ç‡è¶¨å‹¢: ç©©å®šåœ¨ 80% ä»¥ä¸Š
- ç¼ºé™·ç™¼ç¾ç‡: é€éæ¸¬è©¦ç™¼ç¾çš„ bug æ¯”ä¾‹
- å›æ­¸æ¸¬è©¦æ•ˆæœ: é˜²æ­¢åŠŸèƒ½é€€åŒ–çš„æˆåŠŸç‡