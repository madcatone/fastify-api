# TASK 3: CRUD with Drizzle

## ğŸ“‹ ä»»å‹™æ¦‚è¿°

å°‡æ•¸æ“šåº«é·ç§»èˆ‡ CRUD èªå¥æ”¹ç”± Drizzle å¯¦ç¾ï¼Œå»ºç«‹å®Œæ•´çš„è³‡æ–™æ“ä½œæœå‹™å±¤ã€‚

### ğŸ¯ ç›®æ¨™
- å°‡ CRUD æ“ä½œæ”¹ç”¨ Drizzle ORM å¯¦ç¾
- å¯¦ç¾å®Œæ•´çš„è¼¸å…¥é©—è­‰æ©Ÿåˆ¶
- å»ºç«‹çµ±ä¸€çš„éŒ¯èª¤è™•ç†ç³»çµ±
- æ”¯æ´å‹åˆ¥å®‰å…¨çš„æŸ¥è©¢æ“ä½œ
- å¯¦ç¾éƒ¨åˆ†æ›´æ–°åŠŸèƒ½

### ğŸ“Š å‰ç½®æ¢ä»¶
- âœ… TASK 1: Drizzle ORM å·²å®‰è£é…ç½®
- âœ… TASK 2: è³‡æ–™åº« Schema å·²å®šç¾©
- âœ… PostgreSQL è³‡æ–™åº«é‹è¡Œæ­£å¸¸

---

## ğŸ—ï¸ æŠ€è¡“è¦æ ¼

### ğŸ”§ CRUD æ“ä½œè¨­è¨ˆ
- **Create**: æ”¯æ´å–®ç­†å’Œæ‰¹é‡æ–°å¢
- **Read**: æ”¯æ´åˆ†é ã€æ’åºã€ç¯©é¸
- **Update**: æ”¯æ´éƒ¨åˆ†æ›´æ–°å’Œå®Œæ•´æ›´æ–°
- **Delete**: æ”¯æ´è»Ÿåˆªé™¤å’Œç¡¬åˆªé™¤

### ğŸ“ æª”æ¡ˆçµæ§‹

```
apps/server/src/
â”œâ”€â”€ todos/
â”‚   â”œâ”€â”€ service.ts          # è³‡æ–™æœå‹™å±¤
â”‚   â”œâ”€â”€ repository.ts       # è³‡æ–™åº«å­˜å–å±¤
â”‚   â”œâ”€â”€ types.ts           # å‹åˆ¥å®šç¾©
â”‚   â””â”€â”€ validators.ts      # é©—è­‰å™¨
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ errors/            # éŒ¯èª¤è™•ç†
â”‚   â”‚   â”œâ”€â”€ base.ts        # åŸºç¤éŒ¯èª¤é¡
â”‚   â”‚   â”œâ”€â”€ database.ts    # è³‡æ–™åº«éŒ¯èª¤
â”‚   â”‚   â””â”€â”€ validation.ts  # é©—è­‰éŒ¯èª¤
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ pagination.ts  # åˆ†é å·¥å…·
â”‚       â””â”€â”€ response.ts    # å›æ‡‰æ ¼å¼åŒ–
```

---

## ğŸ”¨ å¯¦æ–½æ­¥é©Ÿ

### Step 1: åŸºç¤éŒ¯èª¤è™•ç†ç³»çµ±

```typescript
// apps/server/src/shared/errors/base.ts
export abstract class BaseError extends Error {
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;

  constructor(message: string) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
    Error.captureStackTrace(this);
  }
}

export class ValidationError extends BaseError {
  readonly statusCode = 400;
  readonly isOperational = true;

  constructor(message: string, public readonly details?: any[]) {
    super(message);
  }
}

export class NotFoundError extends BaseError {
  readonly statusCode = 404;
  readonly isOperational = true;

  constructor(resource: string, id?: string) {
    super(`${resource}${id ? ` with id ${id}` : ''} not found`);
  }
}

export class DatabaseError extends BaseError {
  readonly statusCode = 500;
  readonly isOperational = true;

  constructor(message: string, public readonly originalError?: Error) {
    super(message);
  }
}
```

### Step 2: åˆ†é å’ŒæŸ¥è©¢å·¥å…·

```typescript
// apps/server/src/shared/utils/pagination.ts
export interface PaginationParams {
  page: number;
  limit: number;
}

export interface PaginationResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

export const createPaginationResult = <T>(
  data: T[],
  total: number,
  params: PaginationParams
): PaginationResult<T> => {
  const totalPages = Math.ceil(total / params.limit);
  
  return {
    data,
    total,
    page: params.page,
    limit: params.limit,
    totalPages,
    hasNext: params.page < totalPages,
    hasPrev: params.page > 1
  };
};

export const calculateOffset = (page: number, limit: number): number => {
  return (page - 1) * limit;
};
```

### Step 3: å‹åˆ¥å®šç¾©èˆ‡é©—è­‰

```typescript
// apps/server/src/todos/types.ts
import { z } from 'zod';
import type { Todo, NewTodo } from '@fastify-api/db';

// æŸ¥è©¢åƒæ•¸é©—è­‰
export const queryParamsSchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(10),
  author: z.string().optional(),
  isActive: z.coerce.boolean().optional(),
  search: z.string().optional(),
  sortBy: z.enum(['createdAt', 'updatedAt', 'content']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
});

// å»ºç«‹ Todo é©—è­‰
export const createTodoSchema = z.object({
  content: z.string()
    .min(1, 'Content is required')
    .max(1000, 'Content must be less than 1000 characters')
    .trim(),
  author: z.string()
    .min(1, 'Author is required')
    .max(100, 'Author name must be less than 100 characters')
    .trim()
});

// æ›´æ–° Todo é©—è­‰
export const updateTodoSchema = z.object({
  content: z.string()
    .min(1, 'Content cannot be empty')
    .max(1000, 'Content must be less than 1000 characters')
    .trim()
    .optional(),
  author: z.string()
    .min(1, 'Author cannot be empty')
    .max(100, 'Author name must be less than 100 characters')
    .trim()
    .optional(),
  isActive: z.boolean().optional()
}).refine(
  (data) => Object.keys(data).length > 0,
  { message: 'At least one field must be provided for update' }
);

// è·¯ç”±åƒæ•¸é©—è­‰
export const todoParamsSchema = z.object({
  id: z.string().uuid('Invalid UUID format')
});

// TypeScript å‹åˆ¥
export type QueryParams = z.infer<typeof queryParamsSchema>;
export type CreateTodoRequest = z.infer<typeof createTodoSchema>;
export type UpdateTodoRequest = z.infer<typeof updateTodoSchema>;
export type TodoParams = z.infer<typeof todoParamsSchema>;

// æœå‹™å±¤ä»‹é¢
export interface TodoFilters {
  author?: string;
  isActive?: boolean;
  search?: string;
}

export interface TodoSort {
  field: 'createdAt' | 'updatedAt' | 'content';
  order: 'asc' | 'desc';
}

export interface GetTodosOptions {
  pagination: PaginationParams;
  filters?: TodoFilters;
  sort?: TodoSort;
}
```

### Step 4: è³‡æ–™åº«å­˜å–å±¤ (Repository)

```typescript
// apps/server/src/todos/repository.ts
import { db, todos, eq, and, or, like, count, desc, asc, sql } from '@fastify-api/db';
import type { Todo, NewTodo } from '@fastify-api/db';
import type { TodoFilters, TodoSort } from './types';
import { DatabaseError } from '../shared/errors/base';

export class TodoRepository {
  
  // å»ºç«‹ Todo
  async create(data: NewTodo): Promise<Todo> {
    try {
      const [newTodo] = await db.insert(todos).values(data).returning();
      return newTodo;
    } catch (error) {
      throw new DatabaseError('Failed to create todo', error as Error);
    }
  }

  // æ‰¹é‡å»ºç«‹
  async createMany(data: NewTodo[]): Promise<Todo[]> {
    try {
      return await db.insert(todos).values(data).returning();
    } catch (error) {
      throw new DatabaseError('Failed to create todos', error as Error);
    }
  }

  // å–å¾—å–®ä¸€ Todo
  async findById(id: string): Promise<Todo | null> {
    try {
      const [todo] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, id));
      
      return todo || null;
    } catch (error) {
      throw new DatabaseError('Failed to find todo', error as Error);
    }
  }

  // å–å¾—å¤šç­† Todos (æ”¯æ´ç¯©é¸ã€åˆ†é ã€æ’åº)
  async findMany(options: {
    filters?: TodoFilters;
    sort?: TodoSort;
    limit?: number;
    offset?: number;
  } = {}): Promise<{ data: Todo[]; total: number }> {
    try {
      const { filters = {}, sort, limit, offset } = options;
      
      // å»ºç«‹æŸ¥è©¢æ¢ä»¶
      const conditions = this.buildWhereConditions(filters);
      
      // å»ºç«‹æ’åºæ¢ä»¶
      const orderBy = this.buildOrderBy(sort);

      // å–å¾—ç¸½æ•¸
      const [{ total }] = await db
        .select({ total: count() })
        .from(todos)
        .where(conditions);

      // å–å¾—è³‡æ–™
      let query = db
        .select()
        .from(todos)
        .where(conditions)
        .orderBy(orderBy);

      if (limit) {
        query = query.limit(limit);
      }
      
      if (offset) {
        query = query.offset(offset);
      }

      const data = await query;

      return { data, total };
    } catch (error) {
      throw new DatabaseError('Failed to find todos', error as Error);
    }
  }

  // æ›´æ–° Todo
  async update(id: string, data: Partial<NewTodo>): Promise<Todo | null> {
    try {
      const updateData = {
        ...data,
        updatedAt: new Date()
      };

      const [updatedTodo] = await db
        .update(todos)
        .set(updateData)
        .where(eq(todos.id, id))
        .returning();

      return updatedTodo || null;
    } catch (error) {
      throw new DatabaseError('Failed to update todo', error as Error);
    }
  }

  // è»Ÿåˆªé™¤ (è¨­ç‚ºéæ´»èº)
  async softDelete(id: string): Promise<boolean> {
    try {
      const [updatedTodo] = await db
        .update(todos)
        .set({ 
          isActive: false,
          updatedAt: new Date()
        })
        .where(eq(todos.id, id))
        .returning();

      return !!updatedTodo;
    } catch (error) {
      throw new DatabaseError('Failed to soft delete todo', error as Error);
    }
  }

  // ç¡¬åˆªé™¤
  async hardDelete(id: string): Promise<boolean> {
    try {
      const deletedRows = await db
        .delete(todos)
        .where(eq(todos.id, id));

      return deletedRows.rowCount > 0;
    } catch (error) {
      throw new DatabaseError('Failed to delete todo', error as Error);
    }
  }

  // ç§æœ‰æ–¹æ³•ï¼šå»ºç«‹æŸ¥è©¢æ¢ä»¶
  private buildWhereConditions(filters: TodoFilters) {
    const conditions = [];

    if (filters.author) {
      conditions.push(eq(todos.author, filters.author));
    }

    if (filters.isActive !== undefined) {
      conditions.push(eq(todos.isActive, filters.isActive));
    }

    if (filters.search) {
      conditions.push(
        like(todos.content, `%${filters.search}%`)
      );
    }

    return conditions.length > 0 ? and(...conditions) : undefined;
  }

  // ç§æœ‰æ–¹æ³•ï¼šå»ºç«‹æ’åºæ¢ä»¶
  private buildOrderBy(sort?: TodoSort) {
    if (!sort) {
      return desc(todos.createdAt);
    }

    const field = todos[sort.field];
    return sort.order === 'asc' ? asc(field) : desc(field);
  }

  // çµ±è¨ˆæ–¹æ³•
  async getStats(): Promise<{
    total: number;
    active: number;
    inactive: number;
    authorCount: number;
  }> {
    try {
      const [stats] = await db
        .select({
          total: count(),
          active: count(sql`CASE WHEN ${todos.isActive} = true THEN 1 END`),
          inactive: count(sql`CASE WHEN ${todos.isActive} = false THEN 1 END`),
          authorCount: sql<number>`COUNT(DISTINCT ${todos.author})`
        })
        .from(todos);

      return {
        total: stats.total,
        active: stats.active,
        inactive: stats.inactive,
        authorCount: Number(stats.authorCount)
      };
    } catch (error) {
      throw new DatabaseError('Failed to get todo stats', error as Error);
    }
  }
}

export const todoRepository = new TodoRepository();
```

### Step 5: æœå‹™å±¤å¯¦ç¾

```typescript
// apps/server/src/todos/service.ts
import { todoRepository } from './repository';
import type { 
  CreateTodoRequest, 
  UpdateTodoRequest, 
  GetTodosOptions,
  PaginationParams 
} from './types';
import type { Todo } from '@fastify-api/db';
import { NotFoundError, ValidationError } from '../shared/errors/base';
import { createPaginationResult, calculateOffset } from '../shared/utils/pagination';

export class TodoService {
  
  // å»ºç«‹æ–°çš„ Todo
  async createTodo(data: CreateTodoRequest): Promise<Todo> {
    // é¡å¤–çš„æ¥­å‹™é‚è¼¯é©—è­‰
    await this.validateCreateData(data);
    
    return await todoRepository.create(data);
  }

  // æ‰¹é‡å»ºç«‹ Todos
  async createManyTodos(data: CreateTodoRequest[]): Promise<Todo[]> {
    if (data.length === 0) {
      throw new ValidationError('At least one todo is required');
    }

    if (data.length > 50) {
      throw new ValidationError('Cannot create more than 50 todos at once');
    }

    // é©—è­‰æ¯å€‹é …ç›®
    for (const item of data) {
      await this.validateCreateData(item);
    }

    return await todoRepository.createMany(data);
  }

  // å–å¾—å–®ä¸€ Todo
  async getTodoById(id: string): Promise<Todo> {
    const todo = await todoRepository.findById(id);
    
    if (!todo) {
      throw new NotFoundError('Todo', id);
    }

    return todo;
  }

  // å–å¾— Todos åˆ—è¡¨ (æ”¯æ´åˆ†é ã€ç¯©é¸ã€æ’åº)
  async getTodos(options: GetTodosOptions) {
    const { pagination, filters, sort } = options;
    
    // è¨ˆç®— offset
    const offset = calculateOffset(pagination.page, pagination.limit);
    
    // å¾è³‡æ–™åº«å–å¾—è³‡æ–™
    const { data, total } = await todoRepository.findMany({
      filters,
      sort,
      limit: pagination.limit,
      offset
    });

    // å»ºç«‹åˆ†é çµæœ
    return {
      ...createPaginationResult(data, total, pagination),
      filters: filters || {},
      sort: sort || { field: 'createdAt', order: 'desc' }
    };
  }

  // æ›´æ–° Todo
  async updateTodo(id: string, data: UpdateTodoRequest): Promise<Todo> {
    // æª¢æŸ¥ Todo æ˜¯å¦å­˜åœ¨
    const existingTodo = await this.getTodoById(id);
    
    // æ¥­å‹™é‚è¼¯é©—è­‰
    await this.validateUpdateData(data, existingTodo);
    
    const updatedTodo = await todoRepository.update(id, data);
    
    if (!updatedTodo) {
      throw new NotFoundError('Todo', id);
    }

    return updatedTodo;
  }

  // è»Ÿåˆªé™¤ Todo
  async softDeleteTodo(id: string): Promise<void> {
    const success = await todoRepository.softDelete(id);
    
    if (!success) {
      throw new NotFoundError('Todo', id);
    }
  }

  // ç¡¬åˆªé™¤ Todo
  async deleteTodo(id: string): Promise<void> {
    const success = await todoRepository.hardDelete(id);
    
    if (!success) {
      throw new NotFoundError('Todo', id);
    }
  }

  // å–å¾—çµ±è¨ˆè³‡è¨Š
  async getTodoStats() {
    return await todoRepository.getStats();
  }

  // ç§æœ‰é©—è­‰æ–¹æ³•
  private async validateCreateData(data: CreateTodoRequest): Promise<void> {
    // æª¢æŸ¥å…§å®¹æ˜¯å¦é‡è¤‡ (å¯é¸çš„æ¥­å‹™é‚è¼¯)
    const duplicateCheck = await todoRepository.findMany({
      filters: { 
        author: data.author 
      },
      limit: 1
    });

    const hasDuplicate = duplicateCheck.data.some(
      todo => todo.content.toLowerCase() === data.content.toLowerCase()
    );

    if (hasDuplicate) {
      throw new ValidationError(
        'Todo with similar content already exists for this author'
      );
    }
  }

  private async validateUpdateData(
    data: UpdateTodoRequest, 
    existingTodo: Todo
  ): Promise<void> {
    // æª¢æŸ¥æ˜¯å¦çœŸçš„æœ‰è®Šæ›´
    const hasChanges = Object.entries(data).some(([key, value]) => {
      return existingTodo[key as keyof Todo] !== value;
    });

    if (!hasChanges) {
      throw new ValidationError('No changes detected');
    }

    // å¦‚æœæ›´æ–°å…§å®¹ï¼Œæª¢æŸ¥æ˜¯å¦é‡è¤‡
    if (data.content && data.content !== existingTodo.content) {
      const duplicateCheck = await todoRepository.findMany({
        filters: { 
          author: data.author || existingTodo.author 
        },
        limit: 5
      });

      const hasDuplicate = duplicateCheck.data.some(
        todo => todo.id !== existingTodo.id && 
                 todo.content.toLowerCase() === data.content!.toLowerCase()
      );

      if (hasDuplicate) {
        throw new ValidationError(
          'Todo with similar content already exists for this author'
        );
      }
    }
  }
}

export const todoService = new TodoService();
```

### Step 6: å›æ‡‰æ ¼å¼åŒ–å·¥å…·

```typescript
// apps/server/src/shared/utils/response.ts
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  details?: any[];
}

export const createSuccessResponse = <T>(data: T): ApiResponse<T> => ({
  success: true,
  data
});

export const createErrorResponse = (
  error: string, 
  details?: any[]
): ApiResponse<never> => ({
  success: false,
  error,
  details
});

// Fastify éŒ¯èª¤è™•ç†å™¨
export const errorHandler = (error: Error, request: any, reply: any) => {
  if (error instanceof ValidationError) {
    return reply.status(error.statusCode).send(
      createErrorResponse(error.message, error.details)
    );
  }

  if (error instanceof NotFoundError) {
    return reply.status(error.statusCode).send(
      createErrorResponse(error.message)
    );
  }

  if (error instanceof DatabaseError) {
    // ç”Ÿç”¢ç’°å¢ƒä¸æš´éœ²è©³ç´°éŒ¯èª¤
    const message = process.env.NODE_ENV === 'production' 
      ? 'Internal server error' 
      : error.message;
    
    return reply.status(error.statusCode).send(
      createErrorResponse(message)
    );
  }

  // æœªçŸ¥éŒ¯èª¤
  return reply.status(500).send(
    createErrorResponse('Internal server error')
  );
};
```

---

## ğŸ§ª æ¸¬è©¦é©—è­‰

### åŸºæœ¬ CRUD æ¸¬è©¦

```typescript
// æ¸¬è©¦ Service å±¤
describe('TodoService', () => {
  it('should create a new todo', async () => {
    const todoData = {
      content: 'Test todo',
      author: 'test_user'
    };

    const newTodo = await todoService.createTodo(todoData);
    
    expect(newTodo).toBeDefined();
    expect(newTodo.content).toBe(todoData.content);
    expect(newTodo.author).toBe(todoData.author);
    expect(newTodo.isActive).toBe(true);
  });

  it('should get todos with pagination', async () => {
    const result = await todoService.getTodos({
      pagination: { page: 1, limit: 10 }
    });

    expect(result.data).toBeDefined();
    expect(result.total).toBeGreaterThanOrEqual(0);
    expect(result.page).toBe(1);
    expect(result.limit).toBe(10);
  });

  it('should update existing todo', async () => {
    // å…ˆå»ºç«‹ä¸€å€‹ todo
    const newTodo = await todoService.createTodo({
      content: 'Original content',
      author: 'test_user'
    });

    // æ›´æ–° todo
    const updatedTodo = await todoService.updateTodo(newTodo.id, {
      content: 'Updated content'
    });

    expect(updatedTodo.content).toBe('Updated content');
    expect(updatedTodo.updatedAt).not.toEqual(newTodo.updatedAt);
  });
});
```

---

## âœ… å®Œæˆæ¨™æº–

### åŠŸèƒ½éœ€æ±‚
- [x] å®Œæ•´çš„ CRUD æ“ä½œå¯¦ç¾
- [x] è¼¸å…¥é©—è­‰æ©Ÿåˆ¶å»ºç«‹
- [x] éŒ¯èª¤è™•ç†ç³»çµ±å®Œæˆ
- [x] å‹åˆ¥å®‰å…¨çš„æŸ¥è©¢æ“ä½œ
- [x] éƒ¨åˆ†æ›´æ–°åŠŸèƒ½æ”¯æ´

### æŠ€è¡“éœ€æ±‚
- [x] Drizzle ORM æ•´åˆå®Œæˆ
- [x] åˆ†é å’Œç¯©é¸æ©Ÿåˆ¶
- [x] è»Ÿåˆªé™¤å’Œç¡¬åˆªé™¤æ”¯æ´
- [x] çµ±è¨ˆåŠŸèƒ½å¯¦ç¾
- [x] æ¥­å‹™é‚è¼¯é©—è­‰

### å“è³ªéœ€æ±‚
- [x] å‹åˆ¥å®‰å…¨ä¿è­‰
- [x] éŒ¯èª¤è™•ç†å®Œå–„
- [x] ç¨‹å¼ç¢¼å¯ç¶­è­·æ€§
- [x] æ¸¬è©¦è¦†è“‹ç‡é”æ¨™

---

## ğŸ” è³‡æ–™åº«æŸ¥è©¢ç¯„ä¾‹

### è¤‡é›œæŸ¥è©¢ç¤ºä¾‹

```sql
-- å–å¾—ç‰¹å®šä½œè€…çš„æ´»èº todosï¼ŒæŒ‰å»ºç«‹æ™‚é–“æ’åº
SELECT * FROM todos 
WHERE author = 'john_doe' 
AND is_active = true 
ORDER BY created_at DESC 
LIMIT 10 OFFSET 0;

-- æœå°‹åŒ…å«ç‰¹å®šé—œéµå­—çš„ todos
SELECT * FROM todos 
WHERE content ILIKE '%api%' 
AND is_active = true;

-- çµ±è¨ˆå„ä½œè€…çš„ todo æ•¸é‡
SELECT author, COUNT(*) as todo_count 
FROM todos 
WHERE is_active = true 
GROUP BY author 
ORDER BY todo_count DESC;
```

---

## ğŸš€ æ•ˆèƒ½æœ€ä½³åŒ–

### æŸ¥è©¢æœ€ä½³åŒ–
- ä½¿ç”¨é©ç•¶çš„ç´¢å¼•æå‡æŸ¥è©¢æ•ˆèƒ½
- å¯¦ç¾æŸ¥è©¢çµæœå¿«å–æ©Ÿåˆ¶
- åˆ†é æŸ¥è©¢é¿å… N+1 å•é¡Œ

### è¨˜æ†¶é«”æœ€ä½³åŒ–
- æ‰¹é‡æ“ä½œä½¿ç”¨äº‹å‹™è™•ç†
- å¤§é‡è³‡æ–™æŸ¥è©¢ä½¿ç”¨ä¸²æµè™•ç†
- å®šæœŸæ¸…ç†éæ´»èºçš„ todo è¨˜éŒ„

---

## ğŸ“Š ç›£æ§æŒ‡æ¨™

- æŸ¥è©¢åŸ·è¡Œæ™‚é–“: < 100ms
- è¨˜æ†¶é«”ä½¿ç”¨ç‡: < 200MB
- è³‡æ–™åº«é€£æ¥æ•¸: < 10
- éŒ¯èª¤ç‡: < 1%